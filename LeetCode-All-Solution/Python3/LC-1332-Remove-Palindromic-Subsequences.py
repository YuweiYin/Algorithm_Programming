#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""=================================================================
@Project : Algorithm_YuweiYin/LeetCode-All-Solution/Python3
@File    : LC-1332-Remove-Palindromic-Subsequences.py
@Author  : [YuweiYin](https://github.com/YuweiYin)
@Date    : 2022-01-22
=================================================================="""

import sys
import time
# from typing import List
# import collections

"""
LeetCode - 1332 - (Easy) - Remove Palindromic Subsequences
https://leetcode.com/problems/remove-palindromic-subsequences/

Description & Requirement:
    You are given a string s consisting only of letters 'a' and 'b'. 
    In a single step you can remove one palindromic subsequence from s.

    Return the minimum number of steps to make the given string empty.

    A string is a subsequence of a given string 
    if it is generated by deleting some characters of a given string without changing its order. 
    Note that a subsequence does not necessarily need to be contiguous.

    A string is called palindrome if is one that reads the same backward as well as forward.

Example 1:
    Input: s = "ababa"
    Output: 1
    Explanation: s is already a palindrome, so its entirety can be removed in a single step.
Example 2:
    Input: s = "abb"
    Output: 2
    Explanation: "abb" -> "bb" -> "". 
        Remove palindromic subsequence "a" then "bb".
Example 3:
    Input: s = "baabb"
    Output: 2
    Explanation: "baabb" -> "b" -> "". 
        Remove palindromic subsequence "baab" then "b".

Constraints:
    1 <= s.length <= 1000
    s[i] is either 'a' or 'b'.
"""


class Solution:
    def removePalindromeSub(self, s: str) -> int:
        # exception case
        if not isinstance(s, str) or len(s) <= 0:
            return 0  # Error input type
        if len(s) == 1:
            return 1
        if len(s) == 2:
            return 1 if s[0] == s[1] else 2
        # main method: (just small trick)
        #     only "a" and "b", so if step 1 remove all "aa...aa", step 2 remove all "bb...bb", then done
        #     so max step is 2. if s itself is a palindromic string, then only need 1 step.
        # follow up: if chars in s are not limited, then apply greedy alg: remove the longest palin substring each step
        return self._removePalindromeSub(s)

    def _removePalindromeSub(self, s: str) -> int:
        """
        Runtime: 23 ms, faster than 99.72% of Python3 online submissions for Remove Palindromic Subsequences.
        Memory Usage: 13.9 MB, less than 53.87% of Python3 online submissions for Remove Palindromic Subsequences.
        """
        len_s = len(s)
        assert len_s > 2

        def __judge_palindromic_string(cur_string: str) -> bool:
            # double pointer go from both ends, or just one line:  s == s[::-1]
            left_ptr = 0
            right_ptr = len(cur_string) - 1
            while left_ptr <= right_ptr:
                if cur_string[left_ptr] == cur_string[right_ptr]:
                    left_ptr += 1
                    right_ptr -= 1
                else:
                    return False
            return True

        return 1 if __judge_palindromic_string(s) else 2


def main():
    # Example 1: Output: 1
    # s = "ababa"

    # Example 2: Output: 2
    # s = "abb"

    # Example 3: Output: 2
    s = "baabb"

    # init instance
    solution = Solution()

    # run & time
    start = time.process_time()
    ans = solution.removePalindromeSub(s)
    end = time.process_time()

    # show answer
    print('\nAnswer:')
    print(ans)

    # show time consumption
    print('Running Time: %.5f ms' % ((end - start) * 1000))


if __name__ == "__main__":
    sys.exit(main())
