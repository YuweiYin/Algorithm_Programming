# Algorithm - Sort - Linear Time Sort

By [YuweiYin](https://yuweiyin.github.io/)

## 简介

### 线性时间排序

[插入排序](./insertion-sort)、[归并排序](./merge-sort)、[堆排序](./heap-sort)、[快速排序](./quick-sort) 等算法，都属于**比较排序**，其共同点是：在排序的最终结果中，各元素的次序依赖于它们之间的比较。任何比较排序算法的渐近时间复杂度下界是 `\Omega (n log n)`。

比较排序可以被抽象为一棵决策树。这是一棵完全二叉树，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。排序算法的执行对英于一条从树根到某个叶结点的路径，而每个内部结点表示一次元素比较。

![linear-time-sort-1](/img/info-technology/algorithm/sort/linear-time-sort-1.png)

在决策树中，从根结点到任意一个可达叶结点之间的**最长**简单路径的长度，就表示对应的排序算法中**最坏情况**下的比较次数。因此，一个比较排序算法的最坏情况比较次数就等于其决策树的高度。

**定理**：在最坏情况下，任何比较排序算法都需要做 `\Omega (n log n)` 次比较。

**证明**：根据前面的讨论，对于一棵每个排列都是一个可达的叶结点的决策树来说，树的高度完全可以被确定。考虑一棵高度为 h、具有 l 个可达叶结点的决策树，它对应一个对 n 个元素所做的比较排序。因为输入数据的 n! 种可能的排列都是叶结点，所以有 n! <= l。由于在一棵高度为 h 的二叉树中，叶结点的数目不多于 2^h （即完美二叉树的情况），于是有 `n! <= l <= 2^h`，对该式两边取对数，有 `h >= log(n!) = \Omega (n log n)`。

其中，对 log(n!) 中的阶乘 n! 可采用 斯特林公式 Stirling's approximation，即 n! 约等于 `\sqrt{2n \pi} (n/e)^n`

如果不使用斯特林公式，可以如下证明：`log(n!) = \sum_{i=1}^{n} (log i) >= \sum_{i=n/2}^{n} (log i) >= \sum_{i=n/2}^{n} (log (n/2)) = (n/2) log n - n`，故 `h >= log(n!) >= (n/2) (log n - 1) = \Omega (n log n)`

因此，堆排序和归并排序都是**渐进最优**的比较排序算法。（其它比较排序算法都只可能在**常数因子**上优于 堆排序和归并排序）。

而线性时间复杂度的排序算法（包括 Counting Sort 计数排序、Radix Sort 基数排序、Bucket Sort 桶排序等）都是用运算而不是比较来确定排序顺序的，因此其渐近时间复杂度下界**不再**是 `\Omega (n log n)`。

### 计数排序 (Counting Sort)

**计数排序** 假设 n 个输入元素中的每一个都是在 **0 到 k 区间**内的一个**整数**，其中 k 为某个整数。当 k=O(n) 时，排序的运行时间为 `\Theta(n)`。

计数排序的**基本思想**是：对每一个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放置到它该在输出数组中的位置，而不用做比较操作。例如，如果有 17 个元素小于 x，则 x 就应该在第 18 个输出位置上。当有几个元素相同时（类似于哈希表出现冲突碰撞），这一方案要略作修改，因为不能把它们放在同一个输出位置上。

### 基数排序 (Radix Sort)

**基数排序** 对一些 d 位数排序时，先按最低有效位排序，逐次对各有效位排序，直到最高有效位。每次排序采用 Counting Sort 计数排序，其 k 值仅为 10（因为十进制里面，一位数字有 0, 1, 2,..., 9 这十种可能）。

除了上述进行数字排序的场景，基数排序也可用于对具有多关键字域的记录进行排序。例如，用三个关键字（年、月、日）对日期进行升序排列，则先升序排列日、然后排列月、最后排列年。

保证基数排序正确性的一个关键在于：对每位进行排序的算法必须要是稳定的。而计数排序是稳定的。且在 k 值不大的情况下是高效的，因此基数排序常使用计数排序作为其子过程，以进行每一位的排序。

给定 n 个 d 位数，其中每一个数位有 k 个可能的取值。如果基数排序使用的稳定排序算法耗时 `\Theta (n+k)`（比如计数排序），那么它就可以在 `\Theta (d(n+k))` 时间内将这些数排好序。

### 对比基数排序与比较排序

基数排序是否会比基于比较的排序算法（如快速排序）更好呢？通常情况下，如果 b = O(log n)，而且选择 r 约等于 log n，则基数排序的运行时间为 `\Theta (n)`。这一结果看上去要比快速排序的期望运行代价 `\Theta (n log n)` 更好一些。但是，在这两个表达式中，隐藏在 `\Theta` 符号背后的常数项因子是不同的。在处理 n 个关键字时，尽管基数排序执行的循环轮数会比快速排序要少，但每一轮它所耗费的时间要长得多。

哪一个排序算法更合适，依赖于具体实现和底层硬件的特性（例如，快速排序通常可以比基数排序更有效地使用硬件的缓存），以及输入数据的特征。此外，利用计数排序作为中间稳定排序的基数排序不是原址排序（即不能仅通过 O(1) 的辅助空间完成排序），而很多 `\Theta (n log n)` 时间的比较排序是原址排序。因此，当主存的容量比较宝贵时，可能会更倾向于像快速排序这样的原址排序算法。

### 桶排序 (Bucket Sort)

桶排序 Bucket Sort 假设输入数据服从均匀分布，平均情况下它的时间代价为 O(n)。与计数排序类似，因为**对输入数据做了某种假设**，桶排序的速度也很快。

具体来说，计数排序假设数据都属于一个**小区间**内的**整数**，而桶排序则假设输入是由一个随机过程产生的。该过程将元素**均匀、独立**地分布在 \[ 0, 1\) 区间上。

桶排序将 \[ 0, 1\) 区间划分为 n 个相同大小的子区间，或称为**桶**。然后，将 n 个输入数分别放到各个桶中。因为输入数据是**均匀、独立**地分布在 \[ 0, 1\) 区间上，所以一般不会出现很多数落在同一个桶的情况。

在桶排序的代码中，我们假设输入是一个包含 n 个元素的数组 A，且每个元素 A[i] 满足 0 <= A[i] <= 1。此外，算法还需要一个长度为 n 的临时数组 B[0..n-1] 来存放**链表**（即桶），并假设存在一种用于维护这些链表的机制。

### Python

Python 环境：Python 3.7

- **注**：
    - 排序算法的基类 Sort 和元素结构体类 Element 写法与 [此文章](./sort-base-class) 完全相同，故不在下方赘述。
    - 如果要运行此代码，则还需先将 Sort 类和 Element 类置于本代码中。
    - Element 类完全可以根据程序需求来自定义，但是需要给出该类中的 key 和 value 属性名。

### 计数排序 Counting Sort

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/sort/counting-sort.py)

### 基数排序 Radix Sort

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/sort/radix-sort.py)

### 桶排序 Bucket Sort

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/sort/bucket-sort.py)

## 参考资料

- Introduction to Algorithm (aka CLRS) Third Edition - Chapter 8
- MIT 6.006 Introduction to Algorithms, Fall 2011 - [7. Counting Sort, Radix Sort, Lower Bounds for Sorting](https://www.youtube.com/watch?v=Nz1KZXbghj8)
