# Algorithm - Linear Programming

Algorithm - [YuweiYin](https://github.com/YuweiYin)

## 目录

- 线性规划 Linear Programming
	- [单纯形算法](./simplex) Simplex Algorithm

## 线性规划 LP

在给定**有限的资源**和**竞争约束**情况下，很多问题都可以表述为最大化或最小化某个目标的**最优化问题** Optimization。

如果可以把目标描述为**某些变量的一个线性函数**，而且可以将资源的约束指定为这些变量的**等式或不等式**，那么可以得到一个**线性规划问题** (Linear-Programming Problem)：给定线性(等式/不等式)约束情况下的线性函数最优化问题。线性规划出现在许多实际应用中。

### 一般线性规划

在一般线性规划问题中，目标是最优化一个满足一组线性不等式约束的线性函数。

已知一组实数 a1, a2, ..., an 和一组变量 x1, x2, ..., xn。给出定义在这些变量上的一个**线性函数** f：

$$ f(x_{1}, x_{2}, ..., x_{n}) = a_{1} x_{1} + a_{2} x_{2} + ... + a_{n} x_{n} = \sum_{j=1}^{n} a_{j} x_{j} $$

如果 b 是一个实数而 f 是一个线性函数，并记 $ x = (x_{1}, x_{2}, ..., x_{n}) $，则等式 $ f(x) = b $ 是**线性等式**，而不等式 $ f(x) <= b $ 和 $ f(x) >= b $ 是**线性不等式**。线性等式或线性不等式可被统称为**线性约束**。另外，在线性规划问题中，一般不允许严格不等式（即严格小于或严格大于），这意味着允许边界取值情况。

形式化地，一个**线性规划问题**是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线性约束。

如果是要最小化目标线性函数，则称此线性规划为**最小化线性规划**；如果要最大化目标线性函数，则称此线性规划为**最大化线性规划**。此二者通常可以很容易地互相转换，比如 对目标线性函数取相反数。

虽然已有一些线性规划的多项式时间算法，但这里着重研究**单纯形算法**。单纯形算法是最古老的线性规划算法，其最坏情况运行时间不是多项式阶的，但是它在实际应用中相当高效，因此得到广泛使用。

### 线性规划综述

使用**规范形式**来描述线性规划的性质和算法是很方便的：**标准型**、**松弛型**。

非正式地，标准型 LP 是满足线性**不等式**约束的线性函数最优化问题；而松弛型 LP 是满足线性**等式**约束的线性函数最优化问题。通常用标准型来表示线性规划，但当描述单纯形算法时，使用松弛形式会比较方便。

如下讨论满足一组具有 m 个线性不等式约束的、具有 n 个变量的线性函数的最优化问题。

![lp-1](/img/info-technology/algorithm/other-topics/linear-programming/lp-1.png)

线性规划的最优解出现在可行域的一个顶点上并不是偶然。目标线性函数与可行域的边界的交集，要么是一个单独顶点，要么是一条线段。如果交集是一个顶点，那么只有一个最优解，就是该顶点。如果交集是一条线段，那么此线段上的每一点都有相同的目标值。特别地，此线段的两个端点都是最优解。由于线段的端点也是可行域的顶点，所以此情况下最优解也是在一个顶点上。

如果有三个变量，则每个约束对应于三维空间的一个**半空间**。这些半空间的交集形成可行域（凸域/凸集）。目标函数取目标值的点集合 现在变成了一个平面（假设没有非退化的情况出现）。从图形直观上看，如果目标函数的系数都是非负的，而且如果原点是线性规划的一个可行解，那么当把这个平面沿目标函数的垂直方向移开原点时，就可以找到一系列的点，其目标值是递增的。

如同在二维空间一样， 因为**可行域是凸的**，取得最优目标值的点集合**必然包含可行域的一个顶点**。类似地，如果有 n 个变量，每个约束定义了 n 维空间中的一个半空间。则称这些半空间的交集形成的可行区域为**单纯形** (Simplex)。目标函数现在是一个**超平面**，并且因为可行域的凸性，一个最优解仍在单纯形的一个顶点上取得。

**单纯形算法**以一个线性规划作为输入，输出一个最优解(及其最优值)。它从单纯形的某个顶点开始，执行顺序迭代。在每次迭代中，沿着单纯形的**一条边**从**当前顶点**移动到一个 目标值不小于当前值的**相邻顶点**（贪心策略）。当达到一个**局部极大值**时，单纯形算法**终止**。因为可行域是凸的，且目标函数是线性的的，所以该局部极大值就是约束条件下的全局最大值。

### 线性规划的应用

线性规划 LP 有大量的应用。运筹学中大量研究了线性规划的应用。

另外，很多图论问题与线性规划有着密切的关系。例如，可以用 Bellman-Ford 单源最短路径算法求解线性规划中的差分约束系统，可以用将 Max-Flow 最大流问题形式化为线性规划问题。

### 线性规划算法

**单纯形算法**是经典的线性规划算法。当此算法被精心实现时，在实际中通常能够快速地解决一般的线性规划问题。然而对于某些刻意设计的输入，单纯形算法会需要指数时间（即在迭代中很缓慢地搜索，耗费很久才能到达局部最值）。

线性规划问题的第一个多项式时间算法时**椭球算法**，但它在实际中运行缓慢。第二类多项式时间的算法称为**内点法**。与单纯形算法（即沿着可行域的**外部边缘移动**，并在每次迭代中维护一个对应单纯形顶点的可行解）相比，这类算法**在可行区域的内部移动**。中间结点的解尽管是可行的，但未必是单纯形的顶点，但**最终的解是一个顶点**，且是最优解。对于大规模的输入，内点算法的性能可与单纯形算法相当，有时甚至会更快。

如果在一个线性规划中加入额外的要求，即所有的变量都只能取整数值（即可行域是 原本的单纯形 与 离散的整数笛卡尔点集 的交集），那么问题就变成了**整数线性规划**。找出整数线性规划的一个可行解是 NP hard 的。因为目前还没有已知的多项式时间算法能够解任意一个 NP hard 的问题，于是还没有已知的整数线性规划的多项式时间算法。相比而言，可以在多项式时间内求解一般的线性规划问题。

## 标准型和松弛型

在**标准型**中，所有的约束都是**不等式**；而在**松弛型**中，所有的约束都是**等式**（除了要求变量非负之类的约束）。

### 标准型

![lp-2](/img/info-technology/algorithm/other-topics/linear-programming/lp-2.png)

![lp-3](/img/info-technology/algorithm/other-topics/linear-programming/lp-3.png)

### 转换线性规划为标准型

已知一个线性函数满足若干线性条件，要求最小化或最大化它，总可以将这个线性规划转换为标准型。一个线性规划可能由于如下 4 个原因而不是标准型：

1. 目标函数可能是最小化，而不是最大化。
2. 可能有变量不具有非负约束。
3. 可能有等式约束。
4. 可能有大于等于的不等式约束。

对应的转换方法：

1. 为将一个最小化线性规划 L 转换成一个等价的最大化线性规划 L'，只需对**目标函数**中的**系数全部取相反数**即可。
2. 假设某个变量 xj 不具有非负约束，那么把 xj 每次出现的地方都用 xj' - xj'' 来替换，并增加非负约束 xj' >= 0 和 xj'' >= 0。
	- 因此，如果目标函数有一个项为 cj xj，则将之替换为 cj xj' - cj xj''。
	- 如果约束 i 有一个项为 aij xj，则将之替换为为 aij xj' - aij xj''。
	- 新的线性规划的任意可行解 $ \hat x $ 对应于原来线性规划的一个可行解 $ \bar x $。
		- 其中 $ \bar xj = \hat xj' - \hat xj'' $，而且具有相同的目标值。
	- 同样地，原来 LP 的一个可行解 $ \bar x $ 对应于新的 LP 的可行解 $ \hat x $。
		- 其中，若 $ \bar xj >= 0 $，则 $ \hat xj' = \bar xj $ 且 $ \hat xj'' = 0 $；
		- 或者若 $ \bar xj < 0 $，则 $ \hat xj'' = - \bar xj $ 且 $ \hat xj' = 0 $。
3. 将等式约束转换为不等式约束，则只需将原本的等式约束替换为两个不等式约束即可（= 等价于 <= 且 >=）。
4. 将大于等于的不等式约束 左右两端乘以 -1，即可将之转换为小于等于的不等式约束。

### 转换线性规划为松弛型

为了利用单纯形算法高效地求解线性规划问题，更希望将其表示成某些约束是等式约束的形式。更准确地说，将它转换成只有**变量的非负约束**是不等式约束，其余约束都是**等式约束**。

![lp-4](/img/info-technology/algorithm/other-topics/linear-programming/lp-4.png)

![lp-5](/img/info-technology/algorithm/other-topics/linear-programming/lp-5.png)

![lp-6](/img/info-technology/algorithm/other-topics/linear-programming/lp-6.png)

![lp-7](/img/info-technology/algorithm/other-topics/linear-programming/lp-7.png)

## 将问题表达为线性规划

识别一个问题是否可以形式化为一个线性规划问题，就可以用线性规划的解法（如单纯形算法、椭球算法、内点算法等）去求解原问题。

### 最短路径

可以把**单源最短路径问题**形式化为一个线性规划。先讨论**单对**最短路径问题，然后推广到更一般的单源最短路径问题。

在单对最短路径问题中，已知一个**带(边)权有向图** G = (V, E)，**加权函数** w: E -> R 把边映射为实数权值、一个**源顶点 s** (source) 和一个**终点顶点 t** (terminal)。目标是计算从 s 到 t 的一条**最短路径的权值** t.d (distance)。

为了把此问题表示成一个线性规划，需要确定变量和约束的一个集合 来定义什么情况下有从 s 到 t 的一条最短路径。而 Bellman-Ford 算法就可以完成此任务：当 BF 算法终止时，对每个顶点 v，它已计算了一个值 v.d，使得对每条边 (u, v) \in E 有 v.d <= u.d + w(u, v)。源顶点初始得到一个值 s.d = 0 后不会再改变。

因此可以得到如下的线性规划，来计算从 s 到 t 的最短路径权值：

- 最大化：t.d
- 满足约束：
	- v.d <= u.d + w(u, v)  \forall (u, v) \in E
	- s.d == 0

这个线性规划中有 `|V|` 个变量 v.d，对于每个顶点 v \in V 有一个相应变量。另外还有 `|E| + 1` 个约束：每条边上有一个约束，外加源顶点有 s.d == 0 的额外约束。

### 最大流

回顾**最大流问题**，已知一个**有向图** G = (V, E)，其中每条边 (u, v) \in E 有一个**非负的容量值** c(u, v) >= 0，以及两个特殊的顶点：**源点 s** (source) 和**汇点 t** (terminal)。流网络中的一个**流** (flow) 是一个**非负的实值函数** f: V x V -> R，它满足容量限制和流量守恒性质。**最大流** (Max-Flow) 是满足这些约束且最大化流量值的流，其中流量值是从源点 s 流出的总流量值 减去 进入源点 s 的总流量。因此，流满足线性约束并且一个流的值是一个线性函数。

![lp-8](/img/info-technology/algorithm/other-topics/linear-programming/lp-8.png)

重写的思路：对每条(实际存在的)边的流量，维持非负、容量守恒性质，总共 `O(|E|)`；对每个顶点，维持流量守恒性质，总共 `O(|V|)`。

另外，由于二分图/二部图的**最大二分匹配**问题可以被转化为最大流问题来解决，因此它也能被转换为一个线性规划问题。

### 最小费用流

如果一个问题可以转换为线性规划，则可以线性规划的算法来解决此问题，这往往是一种较为通用的方法。但事实上，为一个问题设计一个高效的专用算法，在理论和实践上通常比 LP 更加高效。例如，用于单源最短路径问题的 Dijkstra 算法，用于最大流问题的推送-重贴标签 (push-relabel) 方法。

线性规划的真正能力来自其求解新问题的能力。当对一个新问题缺乏研究、不曾有专用的高效算法时，可以考虑先将之转换为线性规划，并用线性规划算法解决之。

例如，考虑最大流问题的推广——**最小费用流问题**。假设每条边 (u, v) 除了有容量 c(u, v) 外，还有一个实数值的费用 a(u, v)。如果通过边 (u, v) 传送 (u, v).f 个单位的流，那么将产生费用 a(u, v) \* (u, v).f。给定一个流目标 d，希望从 s 到 t 发送 d 个单位的流，同时使得流上产生的总费用最小。

![lp-9](/img/info-technology/algorithm/other-topics/linear-programming/lp-9.png)

### 多商品流

考虑另一个流问题。假设公司要生产多个商品，不同的商品每天需要被运送到不同城市的仓库，而运输图是共用同一个流网络（流网络各边的容量不变/固定）。

![lp-10](/img/info-technology/algorithm/other-topics/linear-programming/lp-10.png)

![lp-11](/img/info-technology/algorithm/other-topics/linear-programming/lp-11.png)

另外，还可以将最小费用流问题与多商品流问题结合起来，形成 **最小费用多商品流问题**：

![lp-12](/img/info-technology/algorithm/other-topics/linear-programming/lp-12.png)

## 参考资料

- Introduction to Algorithm (aka CLRS) Third Edition - Chapter 29
