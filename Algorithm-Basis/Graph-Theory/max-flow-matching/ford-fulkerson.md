# Algorithm - Graph Theory - Ford-Fulkerson

By [YuweiYin](https://yuweiyin.github.io/)

## 简介

最大流 Max-Flow

Ford-Fulkerson 方法

### 流网络

流网络 G = (V, E) 是一个有向图，图中每条边 (u, v) \in E 有一个**非负**的**容量值** c(u, v) >= 0。而且，如果边集合 E 包含一条边 (u, v)，则图中不存在反方向的边 (v, u)。如果 (u, v) \notin E，为方便起见，定义 c(u, v) = 0。并且在图中不允许有自循环/自圈 (u, u)。

另外，在流网络的所有结点中，有两个特殊的结点：**源结点** s (source) 和**汇点** t (terminal)。源结点入度为 0、汇点出度为 0。为方便起见，假定 V 中每个结点 v 都位于某条从 s 到 v 的路径上，即有 `s ~> v ~> t` 路径。

因此，流网络图是**弱连通**的。并且由于除源结点 s 外的每个结点都至少有一条进入的边，有 `|E| >= |V| - 1`。

- 流网络的性质主要如下：
    - 流网络 G = (V, E) 是一个弱连通的有向图
    - 所有边的权重为非负值，且每条边的权重值有上界 c(u, v)
    - 任意两个结点 u, v \in V，不能同时存在边 (u, v) 和边 (v, u)
    - 如果某边 (u, v) 不存在，定义其权重值 c(u, v) = 0
    - 图中没有自循环 (u, u)
    - 通常来说，源结点 s 的入度为 0，汇点 t 的出度为 0
    - 每个结点 v 都处于从 s 到 t 的某条路径上。即：从起点 s 发出的流量可以流经 v 到达终点 t

![max-flow-1](/img/info-technology/algorithm/graph-theory/max-flow-matching/max-flow-1.png)

这里给出流的形式化定义。设 G = (V, E) 是一个**流网络**，其**容量函数**为 c。设 s 为网络的**源结点**，t 为**汇点**。G 中的**流**是一个**实值函数** f: VxV -> R，满足如下两条性质：

1. **容量限制**：（“流量有限额”）对于所有的结点 u, v \in V，要求 0 <= f(u, v) <= c(u, v)
2. **流量守恒**：（“流入等于流出”）对于所有的结点 u \in V - {s, t}，要求 $ \sum_{v \in V} f(v, u) = \sum_{v \in V} f(u, v) $
    - 当 (u, v) \notin E 时，从结点 u 到结点 v 之间没有流，因此 f(u, v) == 0

称非负数值 f(u, v) 为从结点 u 到结点 v 的流。一个流 f 的值 `|f|` 定义如下：

$$ |f| = \sum_{v \in V} f(s, v) = \sum_{v \in V} f(v, s) $$

即，流 f 的值时从源结点流出的总流量 减去 流入源结点的总流量。这里符号 `|·|` 仅用作表达流的值，而不是数的绝对值或者集合的基数值。

通常来说，一个流网络不会有任何进入源结点的边，即源结点的入度为 0，故求和项 $ \sum_{v \in V} f(v, s) $ 的值将是 0。但对于有的网络而言（比如**残存网络**），流入源结点的流量十分重要。

在**最大流问题**中，给定一个**流网络** G、一个**源结点** s、一个**汇点** t，目标是找到值最大的一个**流**。

## Ford-Fulkerson 方法

常用于解决最大流问题的 Ford-Fulkerson 方法，之所以被称为“方法”而不是“算法”，是因为它主要提供的是一种通用的解决思路，包含了几种运行时间不同的具体算法实现。

Ford-Fulkerson 方法依赖于三种重要思想：**残存网络**、**增广路径** 和 **切割**。这三种思想与许多流算法和问题有关，它们是**最大流最小切割定理**（《CLRS》定理 26.6）的精髓。该定理以**流网络的切割**来表述最大流的值。

Ford-Fulkerson 方法**循环增加流的值**：

- 在开始的时候，对于所有的结点 u, v \in V，f(u, v) = 0，给出的初始流量为 0。
- 每一次迭代中，将图 G 的流值进行增加，增加的方法就是在一个关联的“残存网络” Gf 中寻找一条“增广路径”
    - 一旦知道图 Gf 中的一条增广路径的边，就可以很容易地辨别出 G 中的一些具体的边，可以对这些边上的流量进行修改，从而增加流的值。
- 虽然 Ford-Fulkerson 方法的每次迭代都增加流（整体）的值，但是对于图 G 的一条特定边来说，其流量可能增加，也可能减少。
    - 而且，对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。
- 重复对流进行这一过程，知道残存网络中不再存在增广路径为止。最大流最小切割定理将说明在算法终结时，该算法将获得一个最大流。

```
FORD_FULKERSON_METHOD(G, s, t)
1  initialize flow f to 0
2  while there exists an augmenting path p in the residual network Gf
3      augment flow f along p
4  return f
```

为了实现和分析 Ford-Fulkerson 方法，需要引入如下几个新的概念。

### 残存网络

从直观上看，给定流网络 G 和流量 f，残存网络 Gf 由那些 **仍有空间对流量进行调整的边** 构成。流网络的一条边**可以允许的额外流量**等于 该边的容量 减去 该边上的流量。如果该差值为正，则将该条边置于残存网络图 Gf 中，并将其**残存容量**设置为 cf(u, v) = c(u, v) - f(u, v)。对于图 G 中的边来说，只有能够允许额外流量的边才能被加入到图 Gf 中。如果边 (u, v) 的流量 f(u, v) 等于其容量 c(u, v)，则其 cf(u, v) == 0，该条边将不属于图 Gf。（注意，根据**容量限制**原则，残存容量 cf(u, v) 不可能为负值）

残存网络 Gf 中可能包含图 G 中不存在的边。算法对流量进行操作的目标是增加总流量，为此，算法可能对某些特定边上的流量进行缩减，为了表示对一个正流量 f(u, v) 的缩减，将反向边 (v, u) 加入到图 Gf 中，并将其残存容量设置为 cf(v, u) = f(u, v)。即 一条边所能允许的反向流量最多将其正向流量抵消。残存网络中的这些反向边允许算法将已经发送出来的流量发送回去。

而将流量从同一条边发送回去等同于**缩减**该条边的流量，这种操作在许多算法中都是必须的。

更形式化地说，假定有一个流网络 G = (V, E)，其源结点为 s，汇点为 t。设 f 为图 G 中的一个流，考虑结点对 u, v \in V，定义**残存容量** cf(u, v) 如下：

- 若 (u, v) \in E，则 cf(u, v) = c(u, v) - f(u, v)
- 若 (v, u) \in E，则 cf(u, v) = f(v, u)
- 若是其它情况，则 cf(u, v) = 0

由于已经假定在图 G 中边 (u, v) 和边 (v, u) 不能同时出现，故上述三种情况有且仅有一种会发生。

举例来说，如果容量限制 c(u, v) = 16，并且当前流量 f(u, v) = 11，则对 f(u, v) 可以增加的量最多为 cf(u, v) = 5，再多就超过边 (u, v) 的容量限制了。同时，允许算法从结点 v 向结点 u 最多返回 11 单位的流量（即全部当前流量），因此残存网络中反向边 cf(v, u) = 11。

---

给定一个流网络 G = (V, E) 和一个流 f，则由 f 所诱导的图 G 的**残存网络**为 Gf = (V, Ef)，其中边集 Ef = {(u, v) \in V x V: cf(u, v) > 0}

即 残存网络的每条边（称为**残存边**），必须允许大于 0 的流量通过。下面图 26-4 中的 (a) 图是前面图 26-1 (b) 的流网络 G 和流量 f 的重新绘制，图 26-4 (b) 描述的是对应的残存网络 Gf。Ef 中的边要么是 E 中原有的边，要么是其反向边，因此有 `|Ef| <= 2|E|`

![ford-fulkerson-1](/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-1.png)

残存网络 Gf 类似于一个容量为 cf 的流网络，但是不满足前面对流网络的定义，因为在 Gf 中可以有反平行边。除了反平行边这个区别外，流网络的其他性质 Gf 都有保留，因此可以在残存网络中定义一个流，它满足流的两条性质：**容量限制** 和 **流量守恒**。该流针对的是残存网络 Gf 中的残存容量 cf。

残存网络 Gf 中的一个流指出的是一条**路线图**：如何在原来的流网络 G 中增加流。如果 f 是 G 的一个流，f' 是对应的残存网络 Gf 中的一个流，定义 f↑f' 为流 f' 对流 f 的**递增** (augmentation)，它是一个从 V x V 到 R 的函数，具体定义如下：

- 若 (u, v) \in E，则 (f↑f')(u, v) = f(u, v) + f'(u, v) - f'(v, u)
- 其它情况，则 (f↑f')(u, v) = 0

该定义背后的直观解释遵循残存网络的定义。因为在残存网络中**将流量发送到反向边** 等同于 在原来的网络中**缩减流量**，所以将边 (u, v) 的流量增加 f'(u, v)，但减少 f'(v, u)。在残存网络中将流量推送回去 也被称为**抵消操作** (cancellation)。

举例来说，如果某公司将 5 箱货物从城市 u 发送到城市 v，同时将 2 箱同样的货物从城市 v 发送到城市 u，那么可以(从整体上来说)等价于 将 3 箱货物从城市 u 发送到城市 v。这类**抵消操作**对于任何**最大流算法**来说都是**非常关键**的。

---

《CLRS》**引理 26.1**：设 G = (V, E) 为一个流网络，源结点为 s，汇点为 t，设 f 为 G 中的一个流。设 Gf 为由流 f 所诱导的 G 的残存网络，设 f' 为 Gf 中的一个流。那么函数 (f↑f') 是 G 的一个流，其值为 `|f↑f'| = |f| + |f'|`。

对引理 26.1 的证明主要有以下四点（具体证明参考《CLRS》Chapter 26.2）：

1. 流量非负：(f↑f')(u, v) >= 0
2. 容量限制：(f↑f')(u, v) <= c(u, v)
3. 流量守恒：对于所有的结点 u \in V - {s, t}，$ \sum_{v \in V} (f↑f')(u, v) = \sum_{v \in V} (f↑f')(v, u) $
4. 计算 (f↑f') 的值，确保 `|f↑f'| = |f| + |f'|`

### 增广路径

给定流网络 G = (V, E) 和流 f，**增广路径** p 是残存网络 Gf 中一条从源结点 s 到汇点 t 的**简单路径**。根据残存网络的定义，对于一条增广路径上的边 (u, v)，可以增加其流量的幅度 最大为 cf(u, v)，再多会违反容量限制。

例如前面 图 26-4 (b) 中阴影覆盖的路径是一条增广路径。如果将图中的残存网络 Gf 看作一个流网络，那么可以对这条路径上的**每条边的流量增加** 4 个单位，而不会违反容量限制，因为该条路径上**最小的残存容量**是 cf(v2, v3) = 4。

称在一条增广路径 p 上能够为每条边增加的流量的最大值 为路径 p 的**残存容量**，该容量的表达式为：cf(p) = min{cf(u, v): (u, v) 属于路径 p}。下面的引理更加精确地阐述了此论断：

《CLRS》**引理 26.2**：设 G = (V, E) 为一个流网络，设 f 为图 G 中的一个流，设 p 为残存网络 Gf 中的一条增广路径。定义一个函数 fp: V x V -> R 如下：

- 若 (u, v) 在 p 上，则 fp(u, v) = cf(p)
- 若是其它情况，则 fp(u, v) = 0

则 fp 是残存网络 Gf 中的一个流，其值为 `|fp| = cf(p) > 0`

---

下面的推论证明，如果将流 f 增加 fp 的量，则将获得 G 的另一个流，该流的值更加接近最大值。图 26-4 (c) 描述的是对图 26-4 (a) 的流 f 增加图 26-4 (b) 所示的 fp 的量 所获得的结果，而图 26-4 (d) 描述的则是残存网络 Gf。

《CLRS》**推论 26.3**：设 G = (V, E) 为一个流网络，设 f 为 G 中的一个流，设 p 为残存网络 Gf 中的一条增广路径。设 fp 由引理 26.2 所定义，假定将 f 增加 fp 的量，则函数 `|f↑fp| = |f| + |fp| > |f|`。

### 流网络和切割

Ford-Fulkerson 方法的核心就是**沿着增广路径重复增加路径上的流量**，直到找到一个最大流为止。稍后证明的**最大流最小切割定理**表明：一个流是最大流 当且仅当 其残存网络不包含任何增广路径。

流网络 G = (V, E) 中的一个切割 (S, T) 将结点集合 V 划分为 S 和 T=V-S 两个不相交集合，且使得源结点 s \in S、汇点 t \in T。这类似于最小生成树 MST 中的切割，不过这里是对有向图的切割，而非无向图。

若 f 是一个流，则定义横跨切割 (S, T) 的**净流量** f(S, T) 如下：

$$ f(S, T) = \sum_{u \in S} \sum_{v \in T} f(u, v) - \sum_{u \in S} \sum_{v \in T} f(v, u) $$

切割 (S, T) 的**容量**是：

$$ c(S, T) = \sum_{u \in S} \sum_{v \in T} c(u, v) $$

一个网络的**最小切割**是整个网络中**容量最小的切割**。

---

流的定义和切割容量的定义之间不存在对称性，但这种不对称性是有意而为，并且很重要。对于容量来说，只计算从集合 S 发出、进入集合 T 的边的容量，而忽略反方向边上的容量。对于流，考虑的则是从 S 到 T 的总流量 减去 (反方向)从 T 到 S 的流量。

![ford-fulkerson-2](/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-2.png)

下面的引理将证明，对于给定流 f，横跨任何切割的净流量都相同，都等于 `|f|`，即流的值。

《CLRS》**引理 26.4**：设 f 为流网络 G 的一个流，该流网络的源结点为 s，汇点为 t，设 (S, T) 为流网络 G 的**任意切割**，则横跨切割 (S, T) 的净流量为 f(S, T) = `|f|`。

引理 26.4 的如下推论 说明如何使用切割容量来限定一个流的值。

《CLRS》**推论 26.5**：流网络 G 中任意流 f 的值不能超过 G 的任意切割的容量。

此推论给出的一个直接结论是：**一个流网络中最大流的值不能超过该网络最小切割的容量**。这就是下面要来陈述和证明的非常重要的最大流最小切割定理。该定理表明一个最大流的值 事实上等于一个最小切割的容量。

《CLRS》**定理 26.6**（**最大流最小切割定理**）：设 f 为流网络 G = (V, E) 中的一个流，该流网络的源结点为 s，汇点为 t，则下面的条件是等价的：

1. f 是 G 的一个最大流。
2. 残存网络 Gf 不包含任何增广路径。
    - 增广路径：残存网络 Gf 中一条从源结点 s 到汇点 t 的简单路径。
3. 最大流的值 `|f|` = c(S, T)，其中 (S, T) 是流网络 G 的某个切割。

![ford-fulkerson-3](/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-3.png)

## 基本的 Ford-Fulkerson 算法

在 Ford-Fulkerson 方法的每次迭代中，寻找某条增广路径 p，然后使用 p 来对流 f 进行修改（增加）。正如引理 26.2 和推论 26.3 所示，以 f↑fp 来替换 f，从而获得一个值为 `|f| + |fp|` 的更大的流。

在如下算法实现中，通过为每条边 (u, v) \in E 更新流属性 (u, v).f 来计算流网络 G = (V, E) 中的最大流。如果边 (u, v) \notin E，则设置 (u, v).f = 0。另外，假设流网络各边的容量 c(u, v) 都已经给出，如果边 (u, v) \notin E，则设置 c(u, v) = 0。根据如下式子来计算残存容量 cf(u, v)。代码中的表达式 cf(p) 只是一个临时变量，用于存放路径 p 的残存容量。

- 若 (u, v) \in E，则 cf(u, v) = c(u, v) - f(u, v)
- 若 (v, u) \in E，则 cf(u, v) = f(v, u)
- 若是其它情况，则 cf(u, v) = 0

```
FORD_FULKERSON(G, s, t)
1  for each edge(u, v) \in G.E
2      (u, v).f = 0
3  while there exists a path p from s to t in the residual network Gf
4      cf(p) = min { cf(u, v): (u, v) is in path p }
5      for each edge(u, v) in p
6          if (u, v) \in E
7              (u, v).f = (u, v).f + cf(p)
8          else
9              (v, u).f = (v, u).f - cf(p)
```

`FORD_FULKERSON(G, s, t)` 算法是对 `FORD_FULKERSON_METHOD(G, s, t)` 方法的简单扩展。算法流程描述如下：

1. 在 1～2 行，将流 f 初始化为 0。
2. 在 3～9 行的 while 循环中，重复在残存网络 Gf 中寻找一条增广路径 p，然后使用残存容量 cf(p) 来对路径 p 上的流 f 进行增加。路径 p 上的一条边要么是原来网络中的一条边，要么是原来网络中的边 的反向边。
    - 在 4 行，找出路径 p 中的最小残存容量 cf(u, v)。
    - 在 5～9 行的 for 循环中，对路径上 p 的每条边 (u, v) 的流量进行更新。
    - 在 6～7 行，如果残存边 (u, v) 是原来流网络中的一条边，则增加其流量 (u, v).f
    - 在 8～9 行，如果残存边 (u, v) 不是原来流网络中的一条边，则减少其反向边 (v, u) 流量 (v, u).f
3. 最后，当 while 循环结束时，不再有增广路径。根据最大流最小切割定理，此时流 f 就是最大流。

### Ford-Fulkerson 算法的分析

Ford-Fulkerson 算法的运行时间取决于算法第 3 行是如何寻找增广路径 p 的。如果使用广度优先搜索 BFS 来寻找增广路径，算法的运行时间是多项式数量级。如果选择不好，`FORD_FULKERSON` **算法**可能不会终止：流的值会随着后续的递增 (augmentation) 而增加，但它却不一定收敛于最大的流值。

另外，只有当变得容量为**无理数**时，`FORD_FULKERSON_METHOD` **方法**才可能无法终止。下面均假定所选择的任意增广路径 p 和所有的容量 c 都是整数值。在实际情况中，最大流问题中的容量常常都是整数。如果容量为有理数，则可以通过乘以某个系数（或者采用近似值）来将其转换为整数。

---

如果 f\* 表示转换后网络中的一个最大流，则在 `FORD_FULKERSON` 算法的一个直接实现中，执行第 3～9 行的 while 循环的次数最多为 `|f*|` 次，因为流量值在每次迭代中至少增加一个单位。

如果用于实现流网络 G = (V, E) 的数据结构是合理的，并且寻找一条增广路径 p 的算法时间是线性的（比如 DFS 和 BFS），则整个 while 循环的执行将非常高效。假设有一个与有向图 G' = (V, E') 相对应的数据结构，这里 E' = {(u, v): (u, v) \in E 或者 (v, u) \in E}。网络 G 中的边也是网络 G' 中的边，因此在这一数据结构中，保持其容量和流就非常简单了。给定网络 G 的一个流 f，残存网络 Gf 中的边由网络 G' 中所有满足条件 cf(u, v) > 0 的边 (u, v) 所构成，其中 cf 遵守前述残存容量的性质。

因此，如果使用深度优先搜索 DFS 或广度优先搜索 BFS，在一个残存网络中找到一条路径的时间应是 `O(|V| + |E'|) = O(|E|)`。而 while 循环的每一遍执行所需的时间因此为 `O(|E|)`，这与算法第 1～2 行的初始化成本一样，从而整个 `FORD_FULKERSON` 算法的运行时间为 `O(|E|·|f*|)`。

![ford-fulkerson-4](/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-4.png)

![ford-fulkerson-5](/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-5.png)

当容量都是整数值且最优的流量值 `|f*|` 较小时，`FORD_FULKERSON` 算法的运行时间相等不错。但当最优流量值 `|f*|` 取值较大时，可能会效率很慢，如图 26-7 示例。

![ford-fulkerson-6](/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-6.png)

## Edmonds-Karp 算法

可以通过在 `FORD_FULKERSON` 算法第 3 行寻找增广路径 p 的操作中 使用广度优先搜索 BFS 来改善算法的效率。即 在残存网络中选择的增广路径是一条从源结点 s 到汇点 t 的(无权重)最短路径，BFS 时每条边的权重均为单位距离。称如此实现的 Ford-Fulkerson 方法为 Edmonds-Karp 算法，其运行时间为 `O(|V|·|E|^2)`，这就与最优流量值 `|f*|` 的取值大小无关了。

对 Edmonds-Karp 算法的分析取决于残存网络 Gf 中结点之间的距离。下面的引理使用符号 df(u, v) 来表示残存网络 Gf 中从结点 u 到结点 v 的(无权重)最短路径距离，其中每条边的权重为单位距离。

《CLRS》**引理 26.7**：如果 Edmonds-Karp 算法运行在流网络 G = (V, E) 上，该网络的源结点为 s、汇点为 t，则对于所有的结点 v \in V-{s, t}，残存网络 Gf 中**最短路径距离** df(u, v) 随着每次流量的递增 而**单调递增**。

下面的定理给出了 Edmonds-Karp 算法的迭代次数的上界。

《CLRS》**定理 26.8**：如果 Edmonds-Karp 算法运行在源结点为 s、汇点为 t 的流网络 G = (V, E) 上，则该算法所执行的流量递增操作的总次数为 `O(|V|·|E|)`。

![ford-fulkerson-7](/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-7.png)

由于在用广度优先搜索 BFS 寻找增广路径时，`FORD_FULKERSON(G, s, t)` 中的每次迭代可以在 `O(|E|)` 时间内实现，所以 Edmonds-Karp 算法的总运行时间为 `O(|V|·|E|^2)`。

而**推送-重贴标签**算法能够取得更好的界，可以达到 `O(|V|^2·|E|)` 甚至 `O(|V|^3)`。

## 最大二分匹配

一些组合问题可以很容易地标注为最大流问题，例如多源结点多汇点的最大流问题。其它一些组合问题在表面上看似与流网络没有什么关系，但实际上却能够归约到最大流问题，比如**最大二分匹配**问题：在一个二分图(或称“二部图”)中找出一个最大匹配。

解决此问题 将用到由 Ford-Fulkerson 方法所提供的完整性性质 (integrality property)。使用 Ford-Fulkerson 方法能够在 `O(|V|·|E|)` 时间内解决图 G = (V, E) 的最大二分匹配问题。

### 最大二分匹配问题

二分图的最大匹配 (Bipartite Graph Maximum Matching)

给定一个**无向图** G = (V, E)，一个**匹配** (match) 是边的一个子集 $ M \subseteq E $，使得对于所有结点 v \in V，子集 M 中**最多有一条边**与结点 v 关联。如果子集 M 中的某条边与结点 v 关联，则称结点 v **由 M 所匹配**；否则，结点 v 就是**没有匹配**的。**最大匹配**是具有**最大基数**的边集 M。这里的“最大”也是“极大”的意思。

最大匹配问题不仅限于 二分图，即两类事物的最大匹配，而是可以在 n 分图 (n >= 2) 上寻找最大匹配。而二分图的匹配是其中最基础的，也最具有代表性。

在一个二分图中，结点集合 V 有划分 {L, R}，并且边集合 E 中所有的边都横跨 L 和 R。即：任意边 (u, v) \in E，要么 u \in L 且 v \in R，要么 u \in R 且 v in L。进一步假定无向图 G 是**连通**的，因此 V 中的每个结点至少关联了一条边。

![bipartite-graph-maximum-matching-1](/img/info-technology/algorithm/graph-theory/max-flow-matching/bipartite-graph-maximum-matching-1.png)

在二分图中寻找最大匹配问题有许多实际的应用。例如，把一个机器集合 L 和待执行的任务集合 R 相匹配。E 中有边 (u, v) 就说明机器 u \in L 能够完成任务 v \in R。最大匹配能够让尽可能多的机器同时运行。

最大二分匹配问题仅需匹配的基数越大越好，因此边的权重都设定为单位权重，即无权图。但如果考虑边的权重，则可以建模更多的场景，如果在带权图中 希望匹配的总权重值最高，则是最佳匹配的问题了。

### 寻找最大二分匹配

使用 Ford-Fulkerson 方法可以在 `O(|V|·|E|)` 时间内找出(无权)无向二分图 G = (V, E) 的最大匹配。解决这一问题的关键技巧是增加额外的源结点 s 和汇点 t，构造出一个流网络，其中的流对应于匹配，如图 26-8 (c) 所示。

将二分图 G 所对应的流网络 G' = (V', E') 定义如下：设源结点 s 和汇点 t 为原本不属于结点集合 V 的新结点，并设 V' = V \cup {s, t}。如果图 G 的结点集划分为 V = L \cup R，则 E 中所有从 L 指向 R 的边都是流网络 G' 的边。此外 G' 中的边还包括 `|V|` 条新的有向边。E' = {(s, u): u \in L} \cup E \cup {(v, t): v \in R}

最后，给 E' 中的每条边赋予**单位容量**。由于结点集 V 中的每个结点至少有一条相连的边，`|E >= |V| / 2`。因此 `|E| <= |E'| = |E| + |V| <= 3 |E|`，所以 `|E'| = \Theta(|E|)`。

下面的引理证明了图 G 中的一个匹配直接对应 G 所对应的流网络 G' 中的一个流。对于流网络 G = (V, E) 中的一个流 f 来说，如果对于所有的边 (u, v) \in V x V，f(u, v) 都是整数值，则称流 f 是**整数值**的。

《CLRS》**引理 26.9**：设 G = (V, E) 为一个二分图，其结点划分为 V = L \cup R，设 G' = (V', E') 是图 G 所对应的流网络。如果 M 是 G 中的一个匹配，则流网络 G' 中存在一个整数值的流 f，使得 `|f| = |M|`。相反，如果 f 是 G' 中的一个整数值的流，则图 G 中存在一个匹配 M，使得 `|M| = |f|`。

基于引理 26.9，希望得出如下结论：二分图 G 中的一个最大匹配对应于流网络 G' 中的一个最大流，并且可以通过在流网络 G' 上运行一个最大流算法来计算出图 G 中的最大匹配。此结论的得来 存在的唯一障碍是：最大流算法可能返回流网络 G' 中一个非整数的流 f(u, v)，即便流的值 `|f|` 本身必须是整数。不过，下面的定理将说明，如果使用 Ford-Fulkerson 方法，前述问题不会发生，因此前述结论能够成立。

《CLRS》**定理 26.10**（**完整性定理**）：如果容量函数 c 只能取整数值，则 Ford-Fulkerson 方法所生成的最大流 f 满足 `|f|` 是整数值的性质。而且，对于所有的结点 u 和 v，f(u, v) 的值都是整数。

定理 26.10 可以通过对迭代次数进行归纳来证明。下面给出引理 26.9 的一个推论：

《CLRS》**推论 26.11**：二分图 G 中的一个最大匹配 M 的基数 等于 其对应的流网络 G' 中某一最大流 f 的值。

因此，给定一个无向二分图 G，可以通过创建流网络 G'，在其上运行 Ford-Fulkerson 方法来找到一个最大匹配。这个最大匹配 M 可以直接从找到的整数最大流 f 中获得。由于二分图中任何匹配的基数最大值为 min(L, R) = `O(|V|)`，G' 中最大流的值为 `O(|V|)`。又由于 `|E'| = \Theta(|E|)`，所以可以在 `O(|V|·|E'|) = O(|V|·|E|)` 时间内找到一个二分图的最大匹配。

### Hopcroft-Karp 最大二分匹配算法

目前最快的解决最大二分匹配问题的算法是由 Hopcroft 和 Karp[176] 所发明的，其运行时间为 `O(|E|·\sqrt(|V|))`

[176] John E. Hopcroft and Richard M. Karp. An n^{5/2} algorithm for maximum matchings in biparite graphs. *SIAM Journal on Computing*, 2(4):225-231, 1973.

给定一个无向二分图 G = (V, E)，其中 V = L \cup R 并且所有的边都恰有一个端点在集合 L 中，而另一个端点在集合 R 中。设 M 为图 G 的一个匹配。

对于图 G 中的一条简单路径 P，如果该路径的起点是 L 中一个未匹配的结点，终结点是集合 R 中的一个未匹配的结点，而路径上的边交替属于 M 和 E-M，则称路径 P 是一条相对于 M 的增广路径（此增广路径的定义与流网络中的增广路径相关，但并不相同）。

在这里，将一条路径看作是一系列的边，而不是一系列的结点。一条关于匹配 M 的最短增广路径是一条包含最少边数的增广路径。

给定两个集合 A 和 B，**对称差** A \oplus B 定义为 (A-B) \cup (B-A)，即仅在一个集合中出现的元素。

详见《CLRS》思考题 26-6

### 完全匹配

**完全匹配**是指图中所有的结点都得到匹配的匹配。设 G = (V, E) 是结点划分为 V = L \cup R 的无向二分图，其中 `|L| == |R|`。对于任意结点子集 $ X \subseteq V $，定义 X 的**邻居**为：N(X) = {y \in V: 对某个 x \in X，(x, y) \in E}，即由与集合 X 中的元素 相邻的结点所构成的集合。

关于完全匹配，有 **Hall 定理**：图 G 中存在一个完全匹配 当且仅当 对于每个边子集 $ A \subseteq L $，有 `|A| <= |N(A)|`。

### d 正则

对于一个结点划分为 V = L \cup R 的无向二分图 G = (V, E) 而言，如果每个属于结点集合 V 的结点 v 的度数都是自然数 d，则称该二分图是 **d 正则的**。对于每个 d 正则的二分图，都有 `|L| == |R|`。

可以证明：每个 d 正则二分图的匹配基数都是 `|L|`。

证明思路：该二分图对应的流网络的一个最小切割的容量为 `|L|`。

## Python 代码范例

Python 环境：Python 3.7

### Ford-Fulkerson 最大流算法

- Ford-Fulkerson 方法
    - Ford-Fulkerson 算法 O(V |f\*|)
    - Edmonds-Karp 算法 O(V E^2)
- Push-Relabel 推送-重贴标签方法
    - Push-Relabel 通用的推送-重贴标签算法 O(V^2 E)
    - Relabel-To-Front 前置重贴标签算法 O(V^3)

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/graph-theory/max-flow-matching/ford-fulkerson.py)

## 参考资料

- Introduction to Algorithm (aka CLRS) Third Edition - Chapter 26
