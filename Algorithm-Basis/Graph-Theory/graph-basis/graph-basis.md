# Algorithm - Graph Theory - Graph Basis

By [YuweiYin](https://yuweiyin.github.io/)

## 简介

图的表示和搜索

图的搜索指的是系统化地跟随图中的边来访问图中的每个结点。图搜索算法可以用来发现图的结构。许多图算法在一开始都会先通过搜索来获得图的结构，其它的一些图算法则是[对基本的搜索加以优化](../search/)。可以说，图的搜索技巧是整个图算法领域的核心。

## 图的表示

对于图 G = (V, E)，可以用两种标准表示方法表示：

- 将图作为**邻接链表**的组合
- 将图作为**邻接矩阵**来看待

这两种方式都既可以表示无向图，也可以表示有向图 (digraph)。

- 邻接链表非常紧凑，因此常用于表示**稀疏图**（边的条数 `|E|` 远远小于 `|V|^2` 的图）。
- 在**稠密图**（边的条数 `|E|` 接近 `|V|^2` 的图）的情况下，往往更倾向于使用邻接矩阵表示法。
- 另外，如果需要快速判断任意两个结点是否有边相连，可能也需要使用邻接矩阵表示法。

### 邻接链表 Adjacency List

对于图 G = (V, E) 来说，其**邻接链表表示**由一个包含 `|V|` 条链表的数组 Adj 所构成，每个顶点有一条链表。

即：对于每个顶点 $ u \in V $，邻接链表元素 Adj[u] 代表所有**与 u 邻接的顶点链表**的**链表头指针**。该链表中保存着那些顶点(的指针)。

注意，在无向图里，“邻接”关系具有**对称性**，但在有向图中则不不具有对称性(也不具有反对称性)：u **与 v 邻接** 是指从 u 到 v 的有向边。这也等同于：**v 邻接于** u。

如果 G 是一个无向图，那么对于无向边 `(u, v)` 而言，结点 v 会出现在链表 Adj[u] 中，且结点 u 会出现在链表 Adj[v] 中。因此无向图的 Adj 中所有邻接链表到长度之和等于 `2|E|`。

![graph-basis-1](/img/info-technology/algorithm/graph-theory/graph-basis/graph-basis-1.png)

而如果 G 是一个有向图，那么对于有向边 `<u, v>` 而言，结点 v 会出现在链表 Adj[u] 中。因此有向图的 Adj 中所有邻接链表到长度之和等于 `|E|`。

![graph-basis-2](/img/info-technology/algorithm/graph-theory/graph-basis/graph-basis-2.png)

无论对于有向图还是无向图，邻接链表表示法的**存储空间需求**均为 $ \Theta(|V| + |E|) $，对于图算法而言，这就是一种**线性数量级**了。

另外，可以对邻接链表稍加修改，即可以用来表示**权重图**。权重图是图中的**每条边**都带有一个相关权重的图（有时也会对结点赋予权重值）。该权重值通常由一个 w: E->R 的**权重函数**给出，将边映射到一个实数值（权重值往往需要是具有全序关系的）。从这种意义上说，邻接链表表示法的**可扩展性很高**，可以对其进行简单修改来支持许多其它的图变种。

### 邻接矩阵 Adjacency Matrix

邻接链表的一个**潜在缺陷**是无法快速判断边 (u, v) 是否存在于图中，唯一的办法是在邻接链表 Adj[u] 中搜索结点 v，需要耗费 `O(|V|)` 的时间。邻接矩阵(二维数组)克服了这个缺陷，只需 O(1) 时间去判断顶点 u 和 v 是否邻接，但是付出的代价是更大的存储空间 $ \Theta(|V|^2) $。

对于**邻接矩阵表示**来说，通常会将图 G 中的结点编号为 0, 1, ..., `|V|-1`，图 G 的邻接矩阵由一个 `|V| x |V|` 的矩阵 A = (aij) 表达，该矩阵满足如下性质：

- aij = 1  若边 (i, j) \in E
- aij = 0  若边 (i, j) \notin E

如果需要存放带**边权**的权重图，可以将边 (u, v) 的权重值 w(u, v) 直接存储在其邻接矩阵的相应位置。对于不存在的边，用一个预先设定的特殊值（如 0、inf、NIL 等）表达即可。

当然，也可以让邻接矩阵的每个元素 aij 存储的是顶点结构体。但是这样存储空间会占用很多。本身邻接矩阵的元素个数就是 `|V|^2` 了（不管图中有多少边，都会占用 $ \Theta(|V|^2) $ 的空间）。

另外，易知**无向图**的邻接矩阵是一个**对称矩阵**，因此只需存放邻接矩阵的**主对角线**及**上三角矩阵**部分，从而将图存储空间的需求减少近乎一半。

此外，虽然邻接链表表示法和邻接矩阵表示法在渐近意义下至少是一样空间有效的，但**邻接矩阵表示法更为简单**，因此在**图规模比较小**时，往往更倾向于使用邻接矩阵表示法。而且，对于无权图来说，邻接矩阵**每个记录项仅需要 1 bit 的空间**（边存在即为 True、不存在即为 False）。

### 表示图的属性

对图进行操作的多数算法需要维持图中结点或边的某些属性。

在本系列文章里，这些属性可以使用通常的表述法来进行表示，如 v.d 表示结点 v 的属性 d。当使用一对结点来表示一条边时，也可以用同样的方式表述：(u, v).f 表示边 (u, v) 具有属性 f。

但是在算法的实际程序里，实现顶点和边的属性则依赖于诸多因素：所使用的程序设计语言、需要实现的图算法和程序中使用图的方式等。对每个顶点，往往可以构建 Vertex 结构体，但不常为边构造 Edge 结构体，而是将关于边的信息储存在邻接链表结点或邻接矩阵元素中。

### 关联矩阵 Incidence Matrix

有向无环图 G = (V, E) 的**关联矩阵** (Incidence Matrix) 是一个满足如下性质的 `|V| x |E|` 的矩阵 B = (bij)：

- bij = 1  如果边 j 以顶点 i 为起点
- bij = -1 如果边 j 以顶点 i 为终点
- bij = 0  其它情况

“关联”是表示顶点与边之间的关系。对有向图来说，bij = 1 为顶点 i 贡献了 1 个出度，bij = -1 为顶点 i 贡献了 1 个入度。（这个定义完全可以反过来）

### 其它

有向图 G = (V, E) 的**转置**是图 G^T = (V, E^T)，这里 `E^T = {<v, e> \in |V| x |V|: <u, v> \in E}`。即：原 E 中的有向边全部反向。转置是矩阵操作里非常常用的，因此对于邻接链表和邻接矩阵 往往都需要设计一个高效的图转置算法。

如果数组 Adj[u] 的每个记录项不是链表，而是一个散列表，里面包含的是 $ (u, v) \in E $ 的顶点 v。即：以二元元组 (u, v) 为关键字，散列映射到顶点 v。这样可以仅用 O(1) 的期望时间（假设每条边被查询的概率相同）确定某两个顶点是否邻接。

## 图的搜索

### 广度优先搜索 BFS

**广度优先搜索** (Breadth First Search, BFS) 是最简单的图搜索算法之一，也是许多重要的图算法的原型。Prim 的最小生成树算法 和 Dijkstra 的单源最短路径算法 都使用了类似 BFS 的思想。

给定图 G = (V, E) 和一个可以识别的**源结点** s，BFS 对图 G 中的边进行系统性地探索 来发现可以从源结点 s 到达的所有结点。该算法能够计算从源结点 s 到每个可到达的结点的距离（最少的边数 / 最短的路径长度），同时生成一棵“广度优先搜索树”。该树以源结点 s 为根结点，包含所有可以从 s 到达的结点。

对于每个从源结点 s 可以到达的结点 v，在 BFS 树里从结点 s 到结点 v 的简单路径所对应的就是图 G 中从 s 到结点 v 的“最短路径”，即包含最少边数的路径。该算法既可以用于有向图，也可以用于无向图。

“广度优先搜索”顾名思义，始终先沿着当前广度（与源结点的距离）探索，直到当前广度已经不能发现新结点了，则提升广度继续搜索。即：算法需要在发现所有距离源结点 s 为 k 的所有结点之后，才会去发现距离源结点 s 为 k+1 的其它结点。

在 BFS 过程中，所有结点的状态一般有三种：**未被发现**、**已被发现**、**已被探索**。

在执行 BFS 的过程，往往会借助一个先进先出 (FIFO) 的**辅助队列 queue**结构。一开始，辅助队列 Q 中仅有源结点 s，随后将 s 的邻接结点（图表示法既可以是邻接链表，也可以是邻接矩阵）均加入到 Q 中。一旦某个结点 u 的所有邻接结点都被加入到 Q 后，u 就被移除出 Q。此时 u 即为 “已被探索” 状态，不能再被加入 Q 了。

BFS 过程逐步构建出 BFS 树。一开始，树仅有根结点，即源结点 s。在扫描到结点 u 时（u 一开始是 s），查看其邻接链表，将邻接链表中的结点标记为“已被发现”状态（实际上就是将此结点加入辅助队列中）。对于 BFS 树而言，对邻接链表的每一个结点 v，将结点 v 和边 (u, v) 同时加入到该树中，让 v 成为 u 的孩子结点，并称结点 u 是结点 v 的**前驱**或**父结点**。

下面的伪代码描述了 BFS 过程。伪代码中用结点的 color 属性表达三种状态：未被发现、已被发现、已被探索 分别对应 白色 white、灰色 gray、黑色 black。u.p 表示结点 u 的前驱结点，如果没有前驱结点(以及默认值)为 nil。u.d 记录了 BFS 算法所计算出的从源结点 s 到结点 u 的距离(默认值为 inf)。先进先出的辅助队列记为 Q。

```
BFS(G, s)
1  for each vertex u \in G.V - {s}
2      u.color = white
3      u.d = inf
4      u.p = nil
5  s.color = gray
6  s.d = 0
7  s.p = nil
8  Q = \emptyset
9  EnQueue(Q, s)
10 while Q is not empty
11     u = DeQueue(Q)
12     for each v \in G.Adj[u]
13         if v.color == white
14             v.color = gray
15             v.d = u.d + 1
16             v.p = u
17             EnQueue(Q, v)
18     u.color = black
```

算法流程描述：

1. 在 1～4 行，除了源结点 s 外，将其余所有结点 u 的状态标记为“未被发现”，即 color 为白色 white。另外，将 u.d 设置为无穷 inf，表示从源结点不可达结点 u。由于未探索到结点 u，将其前驱结点设置为空 nil。
2. 在 5～7 行，设置源结点 s 的属性。由于已经发现了 s，所以 s.color 设置为灰色 gray。结点 s 到自身的距离为 0。结点 s 为 BFS 树的树根，所以前驱/父结点 u.p 为空 nil。
3. 在 8～9 行，将 s 加入辅助队列 Q，成为其唯一成员。
4. 在 10～18 行的 while 循环中，先进先出地逐个处理队列 Q 中的结点。
    1. 在 11 行，先取出 Q 队首结点 u
    2. 在 12～18 行，逐个处理 u 的所有邻接结点 v
    3. 在 13～17 行，如果 v.color 是白色，表示它未被发现，需要被加入到队列 Q 中。在入队之前，需要设置其属性：
        - v.color 颜色设置为灰色，表示它已被发现，但是尚未被探索完（所谓探索结束，是其邻接结点都已被处理）。
        - v.d 是 v 到源结点 s 的距离，这个距离等于 u.d 距离加上 1
        - v.p 设置前驱/父结点为 u
        - 将 v 入队，之后的 while 循环中 会考察 v 的各个邻接结点
    4. for 循环结束，u 的所有邻接结点都被考察了，所以 u 已经被探索结束了。u.color 设置为黑色，保证不会再被加入队列 Q。

另外，其实灰色 gray 表达的 “已被发现”状态可以不必有，这只是用于辅助思考的（队列中的都是灰色结点，但是可以直接设置为黑色）。省掉灰色后，仅有两个状态，因此可以用 1 bit 来表达此状态信息。

![graph-basis-3](/img/info-technology/algorithm/graph-theory/graph-basis/graph-basis-3.png)

注意：广度优先搜索树的形态可能依赖于 对邻接结点的访问顺序，但是只要源结点 s 不变，那么任意某个结点 u 计算出的 u.d 距离是相同的。

BFS 过程可以确保每个结点的入队次数至多为 1 次，入队出队时间为 O(1)，因此对队列进行操作的总时间为 `O(|V|)`。算法只在某个结点出队时才对该结点的邻接链表进行扫描，所以每个邻接链表最多只被扫描一次。所以扫描邻接链表的总时间为 `O(|E|)`。另外，初始化操作的耗时是 `O(|V|)`，因此 BFS 的总运行时间为 `O(|V| + |E|)`，这是图 G 的邻接链表大小的一个**线性函数**。

### BFS 应用：无权图的最短路径

无(边)权图，或者说每条边的权重值都相等。定义从源结点 s 到结点 v 的**最短路径距离** d(s, v) 为结点 s 到结点 v 之间所有路径里面最少的边数。如果从源结点的 s 到结点 v 之间没有路径，则 d(s, v) = inf 无穷。

称从结点 s 到结点 v 的长度为 d(s, v) 的路径为 s 到 v 的(无权)**最短路径**。下面几个引理和推论证明了 BFS 可以正确计算出源结点 s 到最短路径距离。（无权图 单源最短路径）

《CLRS》**引理 22.1**：给定 G = (V, E)，G 为一个有向图或无向图，设 s \in V 为任意结点，则对于任意边 (u, v) \in E，有 d(s, v) <= d(s, u) + 1。

《CLRS》**引理 22.2**：设 G = (V, E) 为一个有向图或无向图，假定 BFS 以给定结点 s \in V 作为源结点 在图 G 上运行。那么在 BFS 终结时，对于每个结点 v \in V，BFS 所计算出的 v.d 满足 v.d >= d(s, v)。

《CLRS》**引理 22.3**：假定 BFS 在图 G = (V, E) 上运行的过程中，辅助队列 Q 包含的结点为 `<v1, v2, ..., vr>`，这里 v1 是队列 Q 的首结点，vr 是队列 Q 的尾结点。那么 vr.d <= v1.d + 1，并且对于 i = 1, 2, ..., r-1 而言，`vi.d <= v_{i+1}.d`。

《CLRS》**推论 22.4**：假定在执行 BFS 时，结点 vi 和结点 vj 都已经被加入到队列 Q 里，并且 vi 在 vj 之前入队。则在 vj 入队时，有 vi.d <= vj.d。

《CLRS》**定理 22.5**（广度优先搜索的正确性）：设 G = (V, E)，G 为一个有向图或无向图，又假设 BFS 以 s 为源结点在图 G 上运行。那么在算法执行过程中，BFS 将发现从源结点 s **可以到达的所有结点** v \in V，并在算法终止时，对于所有的 v \in V，v.d = d(s, v) 最短路径长度。而且，对于任意可以从 s 到达的结点 v (v != s)，从源结点 s 到结点 v 的其中一条**最短路径**为从结点 s 到结点 v.p 的最短路径再加上边 (v.p, v)，这提供了从 s 到 v 的最短路径的一种构造方法。

### 广度优先树

过程 BFS 在对图进行搜索的过程中将创建一棵广度优先树。对于图 G = (V, E) 和源结点 s，定义图 G 的**前驱子图**为 Gp = (Vp, Ep)，其中顶点集 $ Vp = {v \in V: v.p != nil} \cup {s} $、边集 $ Ep = {(v.p, v): v \in Vp - {s}} $。

即：除源结点 s 以外 所有前驱非空的顶点集合，以及这些顶点与其前驱的所有关联的边集合。

如果对于所有的 v \in Vp，G 的子图 Gp 包含一条从源结点 s 到结点 v 的唯一简单路径，且这条路径也是从 s 到 v 的一条(无边权)最短路径，则前驱子图 Gp 是一棵**广度优先树**。

在 BFS 算法后，通过下面的程序可以打印出一棵广度优先树。

```
PRINT_PATH(G, s, v)
1  if v == s
2      print s
3  elif v.p == nil
4      print "no path from" s "to" v "exists"
5  else
6      PRINT_PATH(G, s, v.p)
7      print v
```

因为每次递归调用时的路径都比前一次调用中的路径少一个结点，所以 PRINT_PATH 过程的运行时间是 `O(|V|)`。

### 深度优先搜索 DFS

**深度优先搜索** (Depth First Search, DFS) 所使用的策略正如其名：只要有可能，就在图中尽量“深入”。DFS 总是对最近才发现的结点 v 的出发边进行探索，知道该结点的**所有出发边都被发现为止**（不重复发现已经发现过的结点，以及已经探索过的出发边）。一旦结点 v 的**所有出发边都被发现**，则“**回溯**”到 v 的前驱结点 v.p，来考察 v.p 的其余出发边（除了已经探索过的出发边）。

许多递归算法的递归树就是一棵深度优先搜索树：先往一个方向(选择)走到尽头，再回溯，考虑另一个选择。

广度优先搜索的前驱子图形成一棵广度优先搜索树，但 DFS 的前驱子图可能由多棵树组成，因为搜索可能从多个源结点重复进行。多棵**深度优先搜索树**形成**深度优先森林**。


与 BFS 类似，DFS 过程也用结点的 color 属性表达三种状态：未被发现、已被发现、已被探索 分别对应 白色 white、灰色 gray、黑色 black。这个方法可以保证每个结点 u 仅在一棵深度优先树中出现。即：以一个源结点 s 开始 DFS 过程得了 DFS 树，就会将树中的所有结点标记为黑色，而其它 DFS 过程不会考虑这些黑色结点。因此，所有深度优先树是不相交的 (disjoint)。

除了创建一个深度优先搜索森林外，DFS 算法还在每个结点上附加一个从 1 开始编号的正整数**时间戳** (timestamp)。每个结点 v 有两个时间戳：第一个时间戳 v.d （这里的 d 是 discover 的意思）记录结点 v 第一次被发现的时间（也就是涂上灰色 gray 的时刻）；第二个时间戳 v.f（这里的 f 是 finish 的意思）记录了完成对 v 的邻接链表扫描的时间（也就是涂上黑色 black 的时刻）。

由于总共 `|V|` 个结点中 每个结点只能有一个发现事件和一个完成事件，所以这些时间戳都是处于 `1 ~ |V|` 之间的整数。而且很显然，结点 u 在时刻 u.d 之前为白色，在时刻 u.d 和 u.f 之间为灰色，在时刻 u.f 之后为黑色。这些时间戳为图结构的分析提供了重要的线索，通常能够有助于推断 DFS 算法的行为。

下面的 DFS 伪代码中，每个结点 u 除了前述 u.d 和 u.f 这两个时间戳属性，还有 u.p 表示结点 u 的前驱结点，如果没有前驱结点(以及默认值)为 nil。变量 time 是一个全局变量，用于计算时间戳。

```
DFS(G)
1  for each vertex u \in G.V
2      u.color = white
3      u.p = nil
4  time = 0
5  for each vertex u \in G.V
6      if u.color == white
7          DFS_VISIT(G, u)
```

1. 在 1～3 行，初始化图 G 的每个顶点 u \in G.V，让其颜色为白色 white、前驱结点/父结点为空 nil。
2. 在 4 行，初始化时间戳 time
3. 在 5～7 行，以每个白色的结点作为 DFS 算法的源结点（也即 DFS 树的根结点）调用 `DFS_VISIT` 过程进行深度优先搜索。

```
DFS_VISIT(G, u)
1  time = time + 1
2  u.d = time
3  u.color = gray
4  for each v \in G.Adj[u]
5      if v.color == white
6          v.p = u
7          DFS_VISIT(G, v)
8  u.color = black
9  time = time + 1
10 u.f = time
```

1. 在 1～3 行，时间戳增长，并赋予给结点 u 的发现时间 u.d。由于 u 已被发现，其颜色置为灰色 gray（已被发现状态）。
2. 在 4～7 行，对于 u 的每个邻接结点 v，如果 v 是白色的（未被发现状态），则将 v 的前驱置为 u，并以 v 为起点递归地进行 DFS 搜索。
3. 在 8～10 行，由于此时 u 的邻接结点都已被处理结束，故置 u 的颜色为黑色（处理完毕状态）。随后时间戳增长，并赋予给结点 u 的完成时间 u.f。

![graph-basis-4](/img/info-technology/algorithm/graph-theory/graph-basis/graph-basis-4.png)

### 深度优先搜索的性质

DFS 提供的是关于图结构很重要的信息。其基本性质是：DFS 生成的前驱子图 Gp 形成一个由多棵树所构成的森林，DFS 树的结构与 `DFS_VISIT` 的递归调用结构完全对应。

另一个重要性质是：结点发现时间和完成时间具有**括号化结构** (parenthesis structure)。如果以左括号 “(u” 来表示结点 u 的发现，以右括号 “u)” 来表示结点 u 的完成，则发现和完成的历史记载形成一个“合法”（左右括号匹配）的表达式。

《CLRS》**定理 22.7**（**括号化定理**）：在对有向或无向图 G = (V, E) 进行的任意深度优先搜索中，对于任意两个结点 u 和 v 来说，下面三种情况有且仅哦与一种成立：

1. 若区间 `[u.d, u.f]` 和区间 `[v.d, v.f]` 完全分离，则在深度优先森林中，结点 u 不是 v 的后代，结点 v 也不是 u 的后代。
2. 若区间 `[u.d, u.f]` 和完全包含在区间 `[v.d, v.f]` 内，则在深度优先树中，结点 u 是 v 的后代。
3. 若区间 `[u.d, u.f]` 和完全包含了区间 `[v.d, v.f]`，则在深度优先树中，结点 v 是 u 的后代。

《CLRS》**推论 22.8**（**后代区间的嵌套**）：在有向或无向图 G 的深度优先森林中，结点 v 是结点 u 的真后代 当且仅当 u.d < v.d < v.f < u.f 成立。

《CLRS》**定理 22.9**（**白色路径定理**）：在有向或无向图 G 的深度优先森林中，结点 v 是结点 u 的后代 当且仅当 在发现结点 u 的时刻 u.d，存在一条从结点 u 到结点 v 的**全部由白色结点所构成的路径**。

《CLRS》练习 22.3-13：一个深度优先搜索的应用是判断一个有向图是否为**单连通图**：对于有向图 G = (V, E) 而言，如果 `u->v` 意味着图 G 至多包含一条从 u 到 v 的简单路径，则图 G 是**单连通图** (single connected)。

《CLRS》练习 22.5-17：给定有向图 G = (V, E)，如果对于所有结点对 u, v \in V，有路径 `u->v` 或 `v->u`，则 G 是**半连通**的。或者说，假如将此有向图的有向边转为无向边，那么如果此无向图是连通图，则原有向图 G 是半连通的。

### 深度优先搜索-边的分类

深度优先搜索的另一个有趣的性质是：可以通过搜索来对输入图 G = (V, E) 的边进行分类。每条边的类型可以提供关于图的重要信息。例如，有向图是无环图 当且仅当 深度优先搜索不产生“后向”边。（《CLRS》引理 22.11）

对于在图上运行深度优先搜索算法所生成的深度优先森林 Gp，可以定义如下 4 种边的类型：

1. **树边**：为深度优先森林 Gp 中的边。如果结点 v 是因算法对边 (u, v) 的探索而**首先被发现**，则 (u, v) 是一条树边。
2. **后向边**：后向边 (u, v) 是将结点 u 连接到其在深度优先树中的(一个)祖先结点 v 的边。由于有向图中可以有自循环，自循环也被认为是后向边。（因此没有后向边的有向图是无环图）
3. **前向边**：将结点 u 连接到其 在深度优先树中的一个后代结点 v 的边 (u, v)。（某祖先结点跨越树边 直接连接到其某个后代结点）
4. **横向边**：除前三类边外的所有边。这些边可以连接同一棵深度优先树中的结点，只要其中一个结点不是另外一个结点的祖先。也可以连接不同深度优先树中的两个结点。

进一步理解：前三类边是同一棵深度优先树中，某个**祖先**结点 a (ancestor) 与其某个**后代**结点 o (offspring) 的有向边：

- 如果有向边是 `<a, o>`
    - 如果 a 是 o 的父结点（也即 o 是 a 的直接孩子结点），那么是**树边**
    - 否则是**前向边**
- 否则是**后向边**

![graph-basis-5](/img/info-technology/algorithm/graph-theory/graph-basis/graph-basis-5.png)

在 DFS 过程中，当**第一次探索**边 (u, v) 时，根据**结点 v 的颜色**可以判断该边的信息：

- 如果此时结点 v 是**白色**，表明该边 (u, v) 是一条**树边**。
- 如果此时结点 v 是**灰色**，表明该边 (u, v) 是一条**后向边**。
- 如果此时结点 v 是**黑色**，表明该边 (u, v) 是一条**前向边**或者**横向边**。

《CLRS》**定理 22.10**：在对**无向图** G 进行**深度优先搜索**时，每条边要么是**树边**，要么是**后向边**。不会出现前向边和横向边。

## DFS - 拓扑排序

深度优先搜索 DFS 有一个重要应用是 对**有向无环图** (Directed Acyclic Graph, DAG) 进行**拓扑排序** (Topological Sorting)。

对于一个有向无环图 G = (V, E) 而言，其**拓扑排序**是 G 中所有结点的一种**线性次序**，该次序满足如下条件：如果图 G 包含有向边 `<u, v>`，则结点 u 在拓扑排序中处于结点 v 的前面。可以将图的拓扑排序看作是将图的所有结点在一条水平线上排开，图的所有有向边的从左指向右。拓扑排序和数组元素的排序（按关键字进行升序/降序排列）是不同的。

许多实际应用都需要使用有向无环图来指明时间的优先次序。比如计算依赖图，要先完成某些计算 才能开始进行另一些计算，因此先进行拓扑排序 可以很好地安排计算次序。

注意到，如果图 G 包含环路，则无法排出一个线性次序，因此拓扑排序的一个重要应用是有向图环路检测。可以在 `O(|V|)` 的运行时间（与边集 E 无关）判断一个给定的**无向图** G = (V, E) 是否包含一个环路。（《CLRS》练习 22.4-3）

![graph-basis-6](/img/info-technology/algorithm/graph-theory/graph-basis/graph-basis-6.png)

下面的伪代码展示了如何对一个有向无环图进行拓扑排序：

```
TOPOLOGICAL_SORT(G)
1  call DFS(G) to compute finishing times v.f for each vertex v
2  as each vertex is finished, insert it into the front of a linked list
3  return the linked list of vertices
```

可以在 `\Theta(|V| + |E|)` 的时间内完成拓扑排序。因为 DFS 需要 `\Theta(|V| + |E|)` 的运行时间。将结点插入到链表最前端所需的时间为 O(1)，而一共只有 `|V|` 个结点需要插入。

《CLRS》**引理 22.11**：一个有向图 G = (V, E) 是**无环的** 当且仅当 对其进行的深度优先搜索**不产生后向边**。

《CLRS》**定理 22.12**：拓扑排序算法 `TOPOLOGICAL_SORT` 生成的是有向无环图的拓扑排序。

## 强连通分量

深度优先搜索的有一个经典应用是：将**有向图**分解为**强连通分量** (Strongly Connected Component, SCC)。有向图 G = (V, E) 的强连通分量是一个最大结点集合 $ C \subseteq V $，对于该集合中的任意一对结点 u 和 v 都彼此可达（存在到达彼此的有向路径）。

许多针对有向图的算法都以此种分解操作开始。在将图分解为强连通分量后，这些算法将分别运行在每个强连通分量上，然后根据连通分量之间的连接结构 将各个结果组合起来，从而获得最终所需的结果。

![graph-basis-7](/img/info-technology/algorithm/graph-theory/graph-basis/graph-basis-7.png)

用于寻找强连通分量的算法需要用到图 G = (V, E) 的转置 G^T = (V, E^T)，其中 $ E^T = {(u, v): (v, u) \in E} $。给定图 G 的邻接链表，创建 G^T 的时间为 `O(|V| + |E|)`。由于强连通分量 和 图转置的性质，图 G 和图 G^T 的强连通分量是完全相同的。

如下伪代码给出了计算有向图 G = (V, E) 强连通分量的 `\Theta(|V| + |E|)` 线性时间算法，其中使用了两次深度优先搜索。这两次 DFS 一次运行在图 G 上，一次运行在其转置图 G^T 上。

```
STRONGLY_CONNECTED_COMPONENT(G)
1  call DFS(G) to compute finishing times u.f for each vertex u
2  compute G^T
3  call DFS(G^T), but in the main loop of DFS, consider the vertices
       in order of decreasing u.f (as computed in line 1)
4  output the vertices of each tree in the depth-first forest formed in line 3
       as a separate strongly connected component
```

此算法背后的思想来自于分量图 G^{SCC} = (V^{SCC}, E^{SCC}) 的一个关键性质，这个关键性质的定义如下：

假定图 G 有强连通分量 C1, C2, ..., Ck。结点集 V^{SCC} 为 {v1, v2, ..., vk}，对于图 G 的每个强连通分量 Ci 而言，该集合包含代表该分量的结点 vi。如果对于某个 x \in Ci 和 y \in Cj，图 G 包含一条有向边 (x, y)，则边 (vi, vj) \in E^{SCC}。从另一个角度来看，通过**收缩**所有相邻结点都在同一个强连通分量中的边，剩下的图就是 G^{SCC}。

分量图的关键性质就是：分量图是一个**有向无环图**。该结论可由如下引理所推出。

《CLRS》**引理 22.13**：设 C 和 C' 为有向图 G = (V, E) 的两个不同的强连通分量，设结点 u, v \in C，结点 u', v' \in C'，假定图 G 包含一条从结点 u 到结点 u' 的路径 `u->u'`。那么图 G 不可能包含一条从结点 v' 到结点 v 的路径 `v'->v`。（从而形成环路）

下面将结点的发现时间 d 和完成时间 f 的概念推广到结点集合上：如果结点集合 $ U \subseteq V $，则定义 d(U) = min{u.d} 和 f(U) = min{u.f}。即：d(U) 和 f(U) 分别是结点集合 U 中所有结点里 最早的发现时间 和 最晚的完成时间。

《CLRS》**引理 22.14**：设 C 和 C' 为有向图 G = (V, E) 的两个不同的强连通分量。假如存在一条边 (u, v) \in E，这里 u \in C 且 v \in C'，则有 `f(C) > f(C')`。

下面的推论表明，转置图 G^T 中连接不同强连通分量的每条边 都是从完成时间较早（第一次 DFS 所计算出的完成时间）的分量 指向完成时间较迟的分量。

《CLRS》**推论 22.15**：设 C 和 C' 为有向图 G = (V, E) 的两个不同的强连通分量。假如存在一条边 (u, v) \in E^T，这里 u \in C 且 v \in C'，则有 `f(C) < f(C')`。

《CLRS》**定理 22.16**：算法 `STRONGLY_CONNECTED_COMPONENT` 能够正确计算出有向图 G 的强连通分量。

从另一个角度来看第二次 DFS 的运行过程，考虑转置图 G^T 的分量图 (G^T)^{SCC}。如果将第二次 DFS 所访问的每个强连通分量 映射到 (G^T)^{SCC} 的一个结点上，则此次 DFS 将以**拓扑排序次序的逆序** 来访问 (G^T)^{SCC} 中的结点。如果将 (G^T)^{SCC} 中的边翻转过来，则将获得 ((G^T)^{SCC})^T。因为 ((G^T)^{SCC})^T = G^{SCC}，所以第二次 DFS 是以**拓扑排序的次序**来访问 G^{SCC} 中的结点的。

## 其它

### 衔接点、桥和双连通分量

设 G = (V, E) 为一个**连通无向图**。图 G 的**衔接点**是指图 G 中的一个结点，如果删除该结点将导致图不连通。图 G 的**桥**是指图 H 中的一条边，如果删除该边将导致图不连通。图 G 的**双连通分量**是指一个最大的边集合，里面的任意两条边都处于同一条简单回路中。可以用 DFS 来判断图 G 的衔接点、桥和双连通分量。

![graph-basis-8](/img/info-technology/algorithm/graph-theory/graph-basis/graph-basis-8.png)

### 欧拉回路

强连通有向图 G = (V, E) 中的一个欧拉回路是指一条**遍历图 G 中每条边恰好一次**的**环路**。性质如下：

- 强连通有向图 G 有一条欧拉回路 当且仅当 对于图中的每个结点 v，都有：入度 in-degree(v) == 出度 out-degree(v)
- 连通无向图 G 有一条欧拉回路 当且仅当 对于图中的每个结点 v，其度数 degree(v) 均为偶数。
    - 由于是连通图，所以不存在度为 0 的孤立点。
    - 又由于度数是非负的，所以此欧拉回路上的每个结点度数是 >= 2 的偶数。

## Python 代码范例

Python 环境：Python 3.7

### 邻接表 & 邻接矩阵

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/graph-theory/graph-basis/graph-basis.py)

### 广度优先搜索 BFS

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/graph-theory/graph-basis/bfs.py)

### 深度优先搜索 DFS

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/graph-theory/graph-basis/dfs.py)

## 参考资料

- Introduction to Algorithm (aka CLRS) Third Edition - Chapter 22
