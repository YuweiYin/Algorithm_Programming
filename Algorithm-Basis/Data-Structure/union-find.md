# Algorithm - Data Structure - Union Find

By [YuweiYin](https://yuweiyin.github.io/)

## 简介

不相交集合 (Disjoint Set)，顾名思义，表示多个不相交的、没有共同元素的集合。我们希望在其上进行两种操作：

- 判断某元素属于哪个集合 find
- 两集合的合并 union

这也正是并查集 (Union Find) 的名称。它使用类似单链表的结构存储各个不同的集合，并用首元素作为整个集合的**代表** (representative) 元素。

并查集的思路简单，原始版本的代码实现也很容易。不过为了优化其效率，使 find 和 union 操作接近常数时间复杂度，一般需要进行如下两种优化（启发式策略）：

- 路径压缩 Path Compression
- 按秩合并 Union by Rank

该算法的常见应用场景如下：

- 图的环路检测，可应用于最小生成树 (Minimum Spanning Tree, MST) 中的 Kruskal 算法
- 集合计数问题，如：计算某个图的连通分支数目、二分图的识别

## 场景描述及分析

并查集主要用于组织存储多个不相交集合（比如图里面的不同连通分支）的数据，以高效实现如下功能：

- `make_set(x)`：建立一个新的集合，它的唯一成员（因而为代表）是 x。
    - 因为初始时各个集合是不相交的，故 x 不会出现在别的某个集合中。
- `find(x)`：查找元素 x 所在的集合是哪个。
    - 常使用集合中的某个代表元素（比如首元素）来表示该集合。
- `union(y, z)`：将元素 y 和元素 z 所在的集合合并成一个集合。
    - 返回值常为合并后的集合的代表元素。
    - 注意：如果 y 和 z 本身就属于同一集合，则此操作不会带来改变。

### 示例

例如：有两个集合 `A = {3, 1, 2}` 和 `B = {8, 7, 9}`

那么 find(2) = A，以及 find(9) = B。

如果用集合中的首元素代表本集合，那么 find(2) = 3，以及 find(9) = 8。

而且，此时可以看出，由于 find(2) 的结果不等于 find(9) 的结果，故可以判断 2 和 9 此时不属于同一个集合。

如果执行 union 操作，如 union(1, 2) = 3，由于 1 和 2 本就在同一集合内，所以本次操作不会改变什么。

又如 union(3, 7) = 3，将集合 A 和 B 合并在了一起，新集合的代表元素（首元素）为 3。

## 设计 & 细节

### 建立集合、基础的 Find 和 Union

可以将此集合抽象为一种链状结构，每个元素结构体含如下属性：

- key：元素的键 key
- father：指向其父元素的指针

初始时，可以设置每个元素的 father 指针指向一个特殊元素，也可以让每个元素的 father 指针指向自己（后者更通用）。

元素之间若要组成集合，可以采取 union 操作。

前文所示集合 A 的结构为 3 <- 1 <- 2，其中 3 有自环。一旦对集合 A 中的元素执行 find 操作，就会随指针逐级向前移动，直到经历了一个自环，就停止在首元素位置，返回 find 结果。类似地，集合 B 的结构为 8 <- 7 <- 9，其中 8 有自环。

集合 A 和集合 B 的结构如下图所示：

![union-find-1](/img/info-technology/algorithm/data-structure/union-find-1.png)

当执行操作 find(2) 时，流程如下：

1. 从元素 2 出发，沿 father 指针移动到元素 1
2. 然后再从元素 1 移动到元素 3
3. 随后发现 3 的 father 指针指向自己，则停止，输出元素 3

当执行操作 find(8) 时，流程类似：从元素 8 出发，发现 8 的父元素还是 8，则停止，输出元素 8

当执行操作 union(1, 2) 时，流程如下：

1. 执行 find(1) 返回元素 3
2. 执行 find(2) 返回元素 3
3. 发现 find(1) 结果等于 find(2)，结束 union，不执行别的操作。

另外，可以稍作优化：如果在执行 find(1) 的途中找到了元素 2，或着是在执行 find(2) 的图中的找到了元素 1，那么可以判断出元素 1 和元素 2 在同一个集合里，此时直接结果 union 操作。但此优化不如下文的**路径压缩**方法有效。

当执行操作 union(3, 7) 时，流程如下：

1. 执行 find(3) 返回元素 3
2. 执行 find(7) 返回元素 8
3. 用一种简单的规则，决定出一个新集合的代表元素。
    - 比如采用 min(3, 8) = 3 为新代表元素，
    - 或者是让 union 函数的第一个参数所在集合的代表元素作为新集合的代表元素。
    - 但更好的优化方案是下文所述的**按秩合并**，选择原本树高更高的集合的代表元素。
4. 让元素 8 的 father 指针指向元素 3，即完成 union 操作。

合并结果如下图所示：

![union-find-2](/img/info-technology/algorithm/data-structure/union-find-2.png)

### 路径压缩 Path Compression

前述每次对某一集合中元素的 find 操作，其时间复杂度都是 O(n)，其中 n 为该集合的元素个数。

这种情况下，大量（设为 q 次）的 find 操作就会导致 O(qn) 的总时间复杂度。

由于 find 操作最终只关心代表元素，因此如果集合中所有元素的 father 指针都能直接指向代表元素，那么每次 find 操作的路径长度就减为 1 了，这也正引出了**路径压缩**的思路：find 路径上，如果当前元素不是集合代表元素，那么它必然会向上移动至其父元素，那么此时让它与它的父元素**同级**，即让当前元素的 father 指针直接指向它的爷爷元素。

例如，当执行操作 find(2) 时，进行路径压缩优化后的流程如下：

1. 从元素 2 出发，发现 2 的 father 指针不指向自己，那么 2 不是首元素，则让元素 2 的 father 指针直接指向其爷爷结点 3，并移动到其父结点 1。
    - 需要 temp 指针记录元素 2 的父结点 1。
2. 然后再从元素 1 出发，同样发现 1 的 father 指针不指向自己，那么 1 不是首元素，则让 1 的 father 指针指向其爷爷结点（同其父结点）3，并移动到其父结点 3。
3. 随后发现 3 的下一个元素还是 3，则停止，输出元素 3

经过路径压缩处理后，find 操作的平均时间复杂度就是 O(1) 常数级别了。

### 按秩合并 Union by Rank

如果待合并的两个集合（树状结构）树高不同，假设集合 A 的树高为 3，集合 B 的树高为 6。

这里**将树高称为秩**，与集合的秩（集合中元素的数目）有所区别。

- 那么如果以集合 A 的代表元素作为合并后新集合的代表元素，新集合的树高为 6 + 1 = 7；
- 如果以集合 B 的代表元素作为合并后新集合的代表元素，那么新集合的树高为 6（因为 3+1 = 4 < 6 不占主导地位）；

显然，降低树高（秩）有助于提升 find 效率，因此在选择新集合的代表元素时，需要**按秩合并**：每次都让秩较小的指向秩较大的，可以使得树高至多为 log_2 (n)，即 find 操作的最坏情况也能是 O(log n) 级别。

### 实现细节

为了按秩合并，需要在集合元素结构体 SetNode 中设置 rank 成员属性。

```python
class SetNode:
    def __init__(self, key):
        self.key = key      # 本元素的 key 号
        self.father = self  # 指针，指向本元素的父结点，初始时指向自己
        self.rank = 1       # 本元素所在集合的 rank 秩
```

为了将 key 映射到 SetNode 结构体，在 UnionFind 类中设置了 key2node 字典。

```python
class UnionFind:
    def __init__(self, key_array):
        self.set_len = len(key_array)
        self.disjoint_set = []    # 存放全体元素 SetNode 结构体
        self.key2node = dict({})  # 将 key 号映射为 SetNode 结构体
```


## 代码范例

### Python

Python 环境：Python 3.7

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/data-structure/union-find.py)

## 参考资料
