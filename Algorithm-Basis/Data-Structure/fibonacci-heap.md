# Algorithm - Data Structure - Fibonacci Heap

By [YuweiYin](https://yuweiyin.github.io/)

## 1. 简介

斐波那契堆 (Fibonacci Heap) 有两种用途：

1. 它支持一系列操作，这些操作构成了所谓的**可合并堆** (mergeable heap)。
2. 斐波那契堆的一些操作可以在常数摊还时间内完成，这使得这种数据结构非常适合于需要频繁调用这些操作的应用。
    - 比如 `decrease_key` 操作可以在常数摊还时间内完成，使得它成为某些迄今为止渐近最快的图问题算法的核心部分。

### 1.1. 可合并堆

**可合并堆** (mergeable heap) 是支持以下 5 种操作的一种数据结构（注意：这里默认为**最小**可合并堆，可类似地构造最大可合并堆），其中每个元素都有关键字域 key：

- `make_heap()`
    - 创建和返回一个新的不含任何元素的堆。
    - 一般而言，创建成功则返回布尔值 True；创建失败则返回布尔值 False。
- `insert(h, x)`
    - 将一个具有关键字 key 的元素 x 插入堆 h 中。
    - 一般而言，插入成功则返回布尔值 True；插入失败则返回布尔值 False。
- `minimum(h)`
    - 返回堆 h 中具有最小关键字的元素 (的指针)。
    - 一般而言，查询失败 (比如堆 h 为空堆) 则返回 NIL 空指针。
- `extract_min(h)`
    - 从堆 h 中删除具有最小关键字的元素，并返回它 (的指针)。
    - 一般而言，操作失败 (比如堆 h 为空堆) 则返回 NIL 空指针。
- `union(h1, h2)`
    - 创建并返回一个包含堆 h1 和堆 h2 中所有元素的新堆 (的指针)。
    - “旧”堆 h1 和 h2 通常会被销毁。
    - 一般而言，合并失败则返回 NIL 空指针。

除了上述 5 个可合并堆的基本操作外，斐波那契堆还支持如下 2 种操作：

- `decrease_key(h, x, k)`
    - 将堆 h 中元素 x 的关键字赋予新值 k
    - 注意：由于这里默认为最小堆，所以新值 k 不大于 x.key。
    - 一般而言，操作成功则返回布尔值 True；操作失败则返回布尔值 False。
    - 也可以通过关键字来定位元素，即 `decrease_key(h, old_k, new_k)`：通过关键字 `old_k` 找到元素 x，并将 x.key 改为 `new_k`。
    - 但是 search 搜索操作在堆结构中是低效的，所以往往传入的参数为元素对象 x。
- `delete(h, x)`
    - 从堆 h 中删除元素 x。
    - 一般而言，删除成功则返回布尔值 True；删除失败则返回布尔值 False。
    - 也可以通过关键字来定位元素，即 delete(h, k)：通过关键字 k 找到元素 x，并将 x 删除。
    - 但是 search 搜索操作在堆结构中是低效的，所以往往传入的参数为元素对象 x。

### 1.2. 斐波那契堆与二项堆堆对比

一般采用摊还分析来分析斐波那契堆的各操作运行时间，与二项堆/二叉堆 (Binary Heap) 的最坏情况对比如下（n 为操作时堆中的项数）：

操作 | 二项堆 (最坏) | 斐波那契堆 (摊还)
:-: | :-: | :-:
make_heap | $ \Theta(1) $ | $ \Theta(1) $
insert | $ \Theta(log n) $ | $ \Theta(1) $
minimum | $ \Theta(1) $ | $ \Theta(1) $
extract_min | $ \Theta(log n) $ | $ O(log n) $
union | $ \Theta(n) $ | $ \Theta(1) $
decrease_key | $ \Theta(log n) $ | $ \Theta(1) $
delete | $ \Theta(log n) $ | $ O(log n) $

可以看出，如果不考虑 union 合并操作需求，堆排序中常常使用的普通二项堆的操作性能相当好。除 union 操作外，二项堆的其它操作均可在最坏情况时间为 O(log n) 下完成。

但是，如果需要支持 union 操作，则二项堆的性能就退化到了 O(n)：通过把两个分别包含 待合并二项堆的数组 进行链接，然后重新建堆，从而实现合并操作。在最坏情况下需要 $ \Theta(n) $ 时间。

另一方面，斐波那契堆对于操作 insert、union 和 `decrease_key` 均比二项堆有更好的渐近时间界。而对于其它几种操作，二者有相同的渐近运行时间。

注意到，二项堆和斐波那契堆对于 search 操作的支持均比较低效：可能需要花费不少的一段时间才能找到具有给定关键字的元素。为此，涉及到给定元素的操作，如 `decrease_key(h, x, k)` 和 `delete(h, x)` 均需要一个指针指向这个元素，并且指针作为输入的一部分。

在应用中使用一个可合并堆时，通常在可合并堆的每个元素中存储一个句柄指向相关应用对象，同样在每个应用对象中也存储一个句柄指向可合并堆中相关元素。这些句柄的确切作用依赖于具体应用及它的实现。

### 1.3. 斐波那契堆：理论 & 实际

理论上看来，当 `extract_min` 和 `delete` 操作的数目相比于其它操作小得多的时候，斐波那契堆尤其适用。这种情形出现在许多应用中。例如，一些图问题算法（如计算最小生成树 MST 和寻找单源最短路径）可能每条边调用一次 `decrease_key`（从而降低边的权值，达到“松弛”的作用）。对于有很多边的稠密图，每次调用 `decrease_key` 需要 $ \Theta(1) $ 的摊还时间，相比于二项堆最坏情况的 $ \Theta(log n) $，累积起来是很大的改进。

然而从实际角度来看，除了某些需要管理大量数据的应用外，对于大多数应用，斐波那契堆的 (隐藏在渐近时间界中的)**常数因子**和**编程复杂性**使得它比普通二项堆（或 k 项堆）并不那么适用。因此，对斐波那契堆的研究往往出于理论兴趣。如果能开发出一个简单得多的数据结构，而且它的摊还时间界与斐波那契堆相同，那么它将非常实用。

## 1.4. 斐波那契堆结构

斐波那契堆也是基于有根树的。通常把每一元素表示成树中的一个结点，每个结点具有一个关键字 key 属性。

一个斐波那契堆 H 时一系列具有**最小堆序** (min-heap ordered) 的有根树的集合（森林 forest）。也就是说，每棵树均为一个**最小堆** (min-heap)，均遵循**最小堆性质** (min-heap property)：每个结点的关键字**小于等于其子结点**的关键字、大于等于其父结点的关键字。示意图如下：

![fibonacci-heap-1](/img/info-technology/algorithm/data-structure/fibonacci-heap-1.png)

每个结点 x 包含一个指向它父结点的指针 x.p 和一个指向它的某一个（仅一个）孩子的指针 x.child。x 所有孩子被连接成一个**循环双向链表**，称为 x 的**孩子链表** (child list)。孩子链表中的每个孩子 y 均有指针 y.left 和 y.right，分别指向 y 的左兄弟和右兄弟。如果 y 是仅有的一个孩子，则 y.left = y.right = y。孩子链表中**各兄弟出现的次序是任意的**。

循环双向链表应用在斐波那契堆中有两个优点：

1. 可以在 O(1) 时间内从循环双向链表的任何位置插入一个结点或删除一个结点，因为 insert 和 delete 传入的参数是元素 x 而不是关键字 k，所以直接修改 x 相关结点的指针域即可。
2. 给定两个循环双向链表，可以用 O(1) 时间把二者链接起来形成一个新的循环双向链表。这有利于 union 合并操作的高效执行。

除上述指针域外，每个结点还有两个属性：

1. 把结点 x 的孩子链表中的孩子数目存储在 x.degree 度数属性中。
2. 布尔值属性 x.mark 指示结点 x 自从上一次成为另一个孩子的结点后，是否失去过孩子。

新产生的结点是未被标记的，即 x.mark = False。当结点 x 成为另一个结点的孩子时，它成为未被标记的结点（因为此时 x 还没有失去孩子）。

斐波那契堆 H 的指针 H.min 指向 H 中具有最小关键字的树的根结点（由于是最小堆，所以这也是整个 H 中的最小关键字结点），该根结点被称为斐波那契堆的**最小结点** (minimum ndoe)。

- 如果不止一个根结点具有最小关键字，那么这些根结点中的任何一个都有可能成为最小结点。
- 如果一个斐波那契堆 H 是空的，那么 H.min 为 NIL 空指针。

在斐波那契堆中，所有树的根也都用其 left 和 right 指针链接成一个循环双向链表，该双链表称为斐波那契堆的**根链表** (root list)。因此，指针 H.min 指向根链表中关键字最小的那个结点（或者几个极小关键字中的某一个）。根链表中的树次序可以是任意的。

除了 H.min 外，斐波那契堆 H 还有另一个属性：H.n 表示 H 中当前含有的结点总数目。

### 1.5. 势函数分析

一般采用**摊还分析** (Amortized Analysis) 中的**势能法** (Potential Method) 来分析斐波那契堆操作的性能。

对于一个给定的斐波那契堆 H，用 t(H) 来表示 H 中根链表中树的数目，用 m(H) 来表示 H 中已被标记（x.mark == True）的结点数目。然后定义斐波那契堆 H 的**势函数** $ \Phi(H) $ 如下：

$$ \Phi(H) = t(H) + 2 m(H) $$

例如，前面示例图的斐波那契堆的势为 5 + 2 \* 3 = 11。一系列斐波那契堆的势等于各个斐波那契堆势的和。假定势的一个单位可以支付常数数目的工作，该常数要足够大，能够支付斐波那契堆实用过程中 可能遇到的任何特定的常数时间工作量。

假定斐波那契堆应用开始时，没有建立堆，因此**势的初始值为 0**。而且根据前述势函数，势在随后的**任何时间内均不为负**。在势能法中，对于某一操作系列来说，总的摊还代价的上界就是其总的实际代价的上界。

### 1.6. 最大度数

在之后的分析中，对于摊还分析均假定：在一个 n 个结点的斐波那契堆中任何结点的**最大度数**都有上界 D(n)。可以证明：如果仅仅是支持可合并堆的操作，那么 $ D(n) <= \floor(log n) $。当支持 `decrease_key` 和 `delete` 操作时，也要求 D(n) = O(log n )。

## 2. 可合并堆操作

核心思想：斐波那契堆上的一些可合并堆操作要尽可能长地**延后执行**。不同的操作可以进行性能平衡。

例如，用将一个结点**加入根链表**的方式来插入一个结点，这样仅需耗费常数时间。如果从空的斐波那契堆开始 插入 k 个结点，斐波那契堆将由一个正好包含 k 个结点的根链表组成。

如果在斐波那契堆 H 上执行一个 `extract_min` 操作，在移除 H.min 指向的结点后，将不得不遍历根链表中剩下的 k-1 个结点来找出新的最小结点，这里便存在摊还的性能平衡问题。只要在执行 extract_min 操作中遍历整个根链表，并且把结点合并到最小堆序树中以减小根链表的规模。

后面可以看到，不论根链表在执行 `extract_min` 操作之前是什么样子，执行完该操作之后，根链表中的每个结点要求有一个 与根链表中其它结点均不同的度数 degree，这使得根链表的规模最大是 D(n) + 1。

### 2.1. 创建一个新的斐波那契堆

make_fib_heap 过程分配并返回一个斐波那契堆对象 H，其中 H.n = 0 和 H.min = NIL，H 中不存在树。因为 t(H) = 0 和 m(H) = 0，空斐波那契堆的势为 $ \Phi(H) = 0 $。因此 make_fib_heap 的摊还代价等于它的实际代价 O(1)。

## 算法流程

以如下键值对列表 (以插入的方式) 构建第一个斐波那契堆 `fib_heap`

```python
# 键值对列表
kv_list = [
    [3, 301], [4, 400], [5, 500], [8, 800],
    [7, 700], [9, 900], [3, 300], [2, 200],
    [6, 600], [10, 1000], [12, 1200], [11, 1100]
]
```

以如下键值对列表 (以插入的方式) 构建第二个斐波那契堆 `fib_heap_2`

```python
kv_list_2 = [
    [16, 1600], [17, 1700], [18, 1800], [1, 100]
]
```

一开始，这两个堆的所有结点都是根结点，都在根链表里。

首先对 `fib_heap` 进行抽取最小结点的测试，示意图如下：

- 注：
    - 从第一次 `extract_min` 结束后的斐波那契堆开始作图。
    - H.min 指针指向堆的最小根。
    - 根链表是循环双向链表，简略成横向的无向边连接。
    - 从某个父结点到其子结点：
        - 向下的有向箭头表示此结点的 child 结点，至多有一个 child 结点；
        - 父子结点间无向的边连接 实则只有孩子结点的 parent 指针往上指。
        - 孩子链表的 left、right 指针均在图中省略。

![fibonacci-heap-2](/img/info-technology/algorithm/data-structure/fibonacci-heap-2.png)

抽取到一定程度（此时 key=7 为最小根结点）后，把两个堆合并起来，然后执行 `decrease_key` 和 `delete` 操作，示意图如下：

![fibonacci-heap-3](/img/info-technology/algorithm/data-structure/fibonacci-heap-3.png)

## 代码范例

### Python

Python 环境：Python 3.7

[GitHub Code Link](https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/data-structure/fibonacci-heap.py)

## 参考资料

- Introduction to Algorithm (aka CLRS) Third Edition - Chapter 19
